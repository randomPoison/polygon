//! Provides a Rust binding to the OpenGL API.
//!
//! This library attempts to provide a complete set of bindings to the OpenGL API while providing
//! a small boost in type-safety over the raw OpenGL API. This library does not abstract the OpenGL
//! API in any way, and in many cases still leaves the task of catching error cases to the
//! programmer. This is meant to be used by other libraries to build higher-level abstractions over
//! raw OpenGL.
//!
//! # Safety Improvements
//!
//! The primary way that `gl-util` improves on the raw OpenGL is by replacing `GLEnum` function
//! parameters with special enum types that only contain variants that are valid options for that
//! function.

#![allow(bad_style)]

#[macro_use]
mod macros;

#[cfg(target_os = "windows")]
#[path="windows.rs"]
pub mod platform;

#[cfg(target_os = "linux")]
#[path="linux.rs"]
pub mod platform;

pub mod types;

use std::mem;

pub use types::*;
pub use platform::*;

pub fn buffer_data<T>(target: BufferTarget, data: &[T], usage: BufferUsage) {
    unsafe {
        buffer_data_raw(
            target,
            (data.len() * mem::size_of::<T>()) as isize,
            data.as_ptr() as *const _,
            usage,
        );
    }
}

pub fn gen_buffer() -> Option<BufferName> {
    let mut buffer_name = BufferName::null();
    unsafe {
        gen_buffers(1, &mut buffer_name);
    }

    if buffer_name.is_null() {
        None
    } else {
        Some(buffer_name)
    }
}

pub fn gen_vertex_array() -> Option<VertexArrayName> {
    let mut vertex_array_name = VertexArrayName::null();
    unsafe {
        gen_vertex_arrays(1, &mut vertex_array_name);
    }

    if vertex_array_name.is_null() {
        None
    } else {
        Some(vertex_array_name)
    }
}

gl_proc!(glActiveTexture:
    /// Selects active texture unit.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glActiveTexture)
    ///
    /// Core since version 1.3
    ///
    /// Selects which texture unit subsequent texture state calls will affect. The number of
    /// texture units an implementation supports is implementation dependent, but must be at least
    /// 96 (80 in GL 4.2, 48 in GL 3.3).
    fn active_texture(texture: u32));

gl_proc!(glAttachShader:
    /// Attaches a shader object to a program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glAttachShader)
    ///
    /// Core since version 2.0
    ///
    /// In order to create a complete shader program, there must be a way to specify the list of
    /// things that will be linked together. Program objects provide this mechanism. Shaders
    /// that are to be linked together in a program object must first be attached to that program
    /// object. `attach_shader` attaches the shader object specified by shader​ to the program
    /// object specified by program​. This indicates that shader​ will be included in link
    /// operations that will be performed on program​.
    ///
    /// All operations that can be performed on a shader object are valid whether or not the
    /// shader object is attached to a program object. It is permissible to attach a shader
    /// object to a program object before source code has been loaded into the shader object or
    /// before the shader object has been compiled. It is permissible to attach multiple shader
    /// objects of the same type because each may contain a portion of the complete shader. It
    /// is also permissible to attach a shader object to more than one program object. If a
    /// shader object is deleted while it is attached to a program object, it will be flagged for
    /// deletion, and deletion will not occur until `detach_shader` is called to detach it from
    /// all program objects to which it is attached.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if either program​ or shader​ is not a value generated by
    ///   OpenGL.
    /// - `glInvalidOperation` is generated if program​ is not a program object.
    /// - `glInvalidOperation` is generated if shader​ is not a shader object.
    /// - `glInvalidOperation` is generated if shader​ is already attached to program​.
    fn attach_shader(program: ProgramObject, shader: ShaderObject));

gl_proc!(glBeginQuery:
    /// Delimits the start of a query object.
    ///
    /// TODO: Add documentation.
    fn begin_query(query_type: QueryType, query: QueryObject));

gl_proc!(glBindBuffer:
    /// Binds a named buffer object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glBindBuffer)
    ///
    /// Core since version 1.5
    ///
    /// Binds a buffer object to the specified buffer binding point. Calling `bind_buffer` with target
    /// set to one of the accepted symbolic constants and buffer​ set to the name of a buffer object
    /// binds that buffer object name to the target. If no buffer object with name buffer​ exists one
    /// is created with that name. When a buffer object is bound to a target the previous binding for
    /// that target is automatically broken.
    ///
    /// Buffer object names are unsigned integers. The value zero is reserved, but there is no default
    /// buffer object for each buffer object target. Instead, buffer​ set to zero effectively unbinds
    /// any buffer object previously bound, and restores client memory usage for that buffer object
    /// target (if supported for that target). Buffer object names and the corresponding buffer object
    /// contents are local to the shared object space of the current GL rendering context; two
    /// rendering contexts share buffer object names only if they explicitly enable sharing between
    /// contexts through the appropriate GL windows interfaces functions.
    ///
    /// `gen_buffers` must be used to generate a set of unused buffer object names.
    ///
    /// A buffer object binding created with `bind_buffer` remains active until a different buffer
    /// object name is bound to the same target or until the bound buffer object is deleted with
    /// `delete_buffers`.
    ///
    /// Once created, a named buffer object may be re-bound to any target as often as needed. However,
    /// the GL implementation may make choices about how to optimize the storage of a buffer object
    /// based on its initial binding target.
    ///
    /// # Buffer Targets
    ///
    /// The state of a buffer object immediately after it is first bound is an unmapped zero-sized
    /// memory buffer with `GL_READ_WRITE` access and `GL_STATIC_DRAW` usage.
    ///
    /// While a non-zero buffer object name is bound GL operations on the target to which it is bound
    /// affect the bound buffer object and queries of the target to which it is bound return state
    /// from the bound buffer object. While buffer object name zero is bound, as in the initial state,
    /// attempts to modify or query state on the target to which it is bound generates an
    /// `GL_INVALID_OPERATION` error.
    ///
    /// When a non-zero buffer object is bound to the `BufferTarget::Array` target the vertex array
    /// pointer parameter is interpreted as an offset within the buffer object measured in basic
    /// machine units (bytes).
    ///
    /// When a non-zero buffer object is bound to the `BufferTarget::DrawIndirect` target parameters
    /// for draws issued through `draw_arrays_indirect` and `draw_elements_indirect` are sourced from
    /// the specified offset in that buffer object's data store.
    ///
    /// When a non-zero buffer object is bound to the `BufferTarget::DispatchIndirect` target, the
    /// parameters for compute dispatches issued through `dispatch_compute_indirect` are sourced from
    /// the specified offset in that buffer object's data store.
    ///
    /// While a non-zero buffer object is bound to the `BufferTarget::ElementArray` target the indices
    /// parameter of `draw_elements`, `draw_elements_instanced`, `draw_elements_base_vertex`,
    /// `draw_range_elements`, `draw_range_elements_base_vertex`, `multi_draw_elements`, or
    /// `multi_draw_elements_base_vertex` is interpreted as an offset within the buffer object
    /// measured in basic machine units (bytes).
    ///
    /// While a non-zero buffer object is bound to the `BufferTarget::PixelPack` target the following
    /// commands are affected: `get_compressed_tex_image`, `get_tex_image`, and `read_pixels`. The
    /// pointer parameter is interpreted as an offset within the buffer object measured in basic
    /// machine units (bytes).
    ///
    /// While a non-zero buffer object is bound to the `BufferTarget::PixelUnpack` target the
    /// following commands are affected: `compressed_tex_image_1d`, `compressed_tex_image_2d`,
    /// `compressed_tex_image_3d`, `compressed_tex_sub_image_1d`, `compressed_tex_sub_image_2d`,
    /// `compressed_tex_sub_image_3d`, `tex_image_1d`, `tex_image_2d`, `tex_image_3d`,
    /// `tex_sub_image_1d`, `tex_sub_image_2d`, and `tex_sub_image_3d`. The pointer parameter is
    /// interpreted as an offset within the buffer object measured in basic machine units (bytes).
    ///
    /// The buffer targets `BufferTarget::CopyRead` and `BufferTarget::CopyWrite` are provided to
    /// allow `copy_buffer_sub_data` to be used without disturbing the state of other bindings.
    /// However, `copy_buffer_sub_data` may be used with any pair of buffer binding points.
    ///
    /// The `BufferTarget::TransformFeedback` buffer binding point may be passed to `bind_buffer`, but
    /// will not directly affect transform feedback state. Instead, the indexed
    /// `BufferTarget::TransformFeedback` bindings must be used through a call to `bind_buffer_base` or
    /// `bind_buffer_range`. This will affect the generic `BufferTarget::TransformFeedback` binding.
    ///
    /// Likewise, the `BufferTarget::Uniform`, `BufferTarget::AtomicCounter` and
    /// `BufferTarget::ShaderStorage` buffer binding points may be used but do not directly affect
    /// uniform buffer, atomic counter buffer, or shader storage buffer state, respectively.
    /// `bind_buffer_base` or `bind_buffer_range` must be used to bind a buffer to an indexed uniform
    /// buffer, atomic counter buffer, or storage buffer binding point.
    ///
    /// The `BufferTarget::Query` binding point is used to specify a buffer object that is to receive
    /// the results of query objects through calls to the `get_query_object` family of commands.
    ///
    /// # Version Availability
    ///
    /// - The `Read`, `Uniform`, and `Texture` targets are available only if the GL version is 3.1 or
    ///   greater.
    /// - The `AtomicCounter` target is available only if the GL version is 4.2 or greater.
    /// - The `DispatchIndirect` and `ShaderStorage` targets are available only if the GL version is
    ///   4.3 or greater.
    /// - The `Query` target is available only if the GL version is 4.4 or greater.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if buffer​ is not a name previously returned from a call to
    ///   `gen_buffers`.
    fn bind_buffer(target: BufferTarget, buffer: BufferName));

gl_proc!(glBindTexture:
    /// Binds a named texture to a texturing target.
    ///
    /// Lets you create or use a named texture. Calling `bind_texture` with target​ set to
    /// `Texture1d`, `Texture2d`, `Texture3d`, `Texture1dArray`, `Texture2dArray`,
    /// `TextureRectangle`, `TextureCubeMap`, `TextureCubeMapArray`, `TextureBuffer`,
    /// `Texture2dMultisample` or `Texture2dMultisampleArray` and texture​ set to the name of the
    /// new texture binds the texture name to the target. When a texture is bound to a target
    /// the previous binding for that target is automatically broken.
    ///
    /// Texture names are `u32` values. The value zero is reserved to represent the default
    /// texture for each texture target. Texture names and the corresponding texture contents are
    /// local to the shared object space of the current GL rendering context; two rendering
    /// contexts share texture names only if they explicitly enable sharing between contexts
    /// through the appropriate GL windows interfaces functions.
    ///
    /// You must use `gen_textures` to generate a set of new texture names.
    ///
    /// When a texture is first bound it assumes the specified target: A texture first bound to
    /// `Texture1d` becomes one-dimensional texture, a texture first bound to `Texture2d` becomes
    /// two-dimensional texture, a texture first bound to `Texture3d` becomes three-dimensional
    /// texture, a texture first bound to `Texture1dArray` becomes one-dimensional array texture,
    /// a texture first bound to `Texture2dArray` becomes two-dimensional arary texture, a
    /// texture first bound to `TextureRectangle` becomes rectangle texture, a texture first
    /// bound to `TextureCubeMap` becomes a cube-mapped texture, a texture first bound to
    /// `TextureCubeMapArray` becomes a cube-mapped array texture, a texture first bound to
    /// `TextureBuffer` becomes a buffer texture, a texture first bound to `Texture2dMultisample`
    /// becomes a two-dimensional multisampled texture, and a texture first bound to
    /// `Texture2dMultisampleArray` becomes a two-dimensional multisampled array texture. The
    /// state of a one-dimensional texture immediately after it is first bound is equivalent to
    /// the state of the default `Texture1d` at GL initialization, and similarly for the other
    /// texture types.
    ///
    /// While a texture is bound, GL operations on the target to which it is bound affect the
    /// bound texture, and queries of the target to which it is bound return state from the bound
    /// texture. In effect, the texture targets become aliases for the textures currently bound
    /// to them, and the texture name zero refers to the default textures that were bound to them
    /// at initialization.
    ///
    /// A texture binding created with `bind_texture` remains active until a different texture
    /// is bound to the same target, or until the bound texture is deleted with
    /// `delete_textures`.
    ///
    /// Once created, a named texture may be re-bound to its same original target as often as
    /// needed. It is usually much faster to use `bind_texture` to bind an existing named
    /// texture to one of the texture targets than it is to reload the texture image using
    /// `tex_image_1d`, `tex_image_2d`, `tex_image_3d` or another similar function.
    ///
    /// # Notes
    ///
    /// * The `Texture2dMultisample` and `Texture2dMultisampleArray` targets are available only
    ///   if the GL version is 3.2 or higher.
    ///
    /// # Errors
    ///
    /// * `GL_INVALID_VALUE` is generated if target​ is not a name returned from a previous call
    ///   to `gen_textures`.
    /// * `GL_INVALID_OPERATION` is generated if texture​ was previously created with a target
    ///   that doesn't match that of target​.
    fn bind_texture(target: TextureBindTarget, texture: TextureObject));

gl_proc!(glBindVertexArray:
    /// Binds a named vertex array object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glBindVertexArray)
    ///
    /// Core since version 3.0
    ///
    /// Binds the vertex array object with `name`. `name` is the name of a vertex array object
    /// previously returned from a call to `gen_vertex_arrays`, or zero to break the existing vertex
    /// array object binding.
    ///
    /// If no vertex array object with name array​ exists, one is created when array​ is first bound.
    /// If the bind is successful no change is made to the state of the vertex array object, and any
    /// previous vertex array object binding is broken.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_OPERATION` is generated if array​ is not zero or the name of a vertex array
    ///   object previously returned from a call to `gen_vertex_arrays`.
    fn bind_vertex_array(name: VertexArrayName));

gl_proc!(glBlendFunc:
    /// Specifies pixel arithmetic for both RGB and alpha components.
    ///
    /// Pixels can be drawn using a function that blends the incoming (source) RGBA values with
    /// the RGBA values that are already in the frame buffer (the destination values). Blending is
    /// initially disabled. Use `enable` and `disable` with argument `ServerCapability::Blend` to
    /// enable and disable blending.
    ///
    /// `blend_func` is equivalent to calling `blend_func_separate` with `src_factor` for both the
    /// `src_rbg` and `src_alpha` parameters, and `dest_factor` for both the `dest_rbg` and
    /// `dest_alpha` parameters.
    ///
    /// In the table and in subsequent equations, first source, second source and destination
    /// color components are referred to as (Rs0, Gs0, Bs0, As0), (Rs1, Gs1, Bs1, As1) and (Rd,
    /// Gd, Bd, Ad), respectively. The color specified by glBlendColor​ is referred to as (Rc, Gc,
    /// Bc, Ac).
    ///
    /// Source and destination scale factors are referred to as (sR, sG, sB, sA) and (dR, dG, dB,
    /// dA).
    ///
    /// | Parameter             | RGB Factor                  | Alpha Factor |
    /// |-----------------------|-----------------------------|--------------|
    /// | Zero                  | (0, 0, 0)                   | 0            |
    /// | One                   | (1, 1, 1)                   | 1            |
    /// | SourceColor           | (Rs0, Gs0, Bs0)             | As0          |
    /// | OneMinusSourceColor   | (1, 1, 1) - (Rs0, Gs0, Bs0) | 1 - As0      |
    /// | DestColor             | (Rd, Gd, Bd)                | Ad           |
    /// | OneMinusDestColor     | (1, 1, 1) - (Rd, Gd, Bd)    | 1 - Ad       |
    /// | SourceAlpha           | (As0, As0, As0)             | As0          |
    /// | OneMinusSourceAlpha   | (1, 1, 1) - (As0, As0, As0) | 1 - As0      |
    /// | DestAlpha             | (Ad, Ad, Ad)                | Ad           |
    /// | OneMinusDestAlpha     | (1, 1, 1) - (Ad, Ad, Ad)    | Ad           |
    /// | ConstantColor         | (Rc, Gc, Bc)                | Ac           |
    /// | OneMinusConstantColor | (1, 1, 1) - (Rc, Gc, Bc)    | 1 - Ac       |
    /// | ConstantAlpha         | (Ac, Ac, Ac)                | Ac           |
    /// | OneMinusConstantAlpha | (1, 1, 1) - (Ac, Ac, Ac)    | 1 - Ac       |
    /// | SourceAlphaSaturate   | (i, i, i)                   | 1            |
    /// | Source1Color          | (Rs1, Gs1, Bs1)             | As1          |
    /// | OneMinusSourceColor   | (1, 1, 1) - (Rs1, Gs1, Bs1) | 1 - As1      |
    /// | Source1Alpha          | (As1, As1, As1)             | As1          |
    /// | OneMinusSourceAlpha   | (1, 1, 1) - (As1, As1, As1) | 1 - As1      |
    ///
    /// In the table,
    ///
    /// ```
    /// i = min(As0, (1 - Ad))
    /// ```
    ///
    /// Despite the apparent precision of the above equations, blending arithmetic is not exactly
    /// specified, because blending operates with imprecise integer color values. However, a blend
    /// factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend
    /// factor equal to 0 reduces its multiplicand to 0. For example, when `src_factor` is
    /// `SourceAlpha`, `dest_factor` is `OneMinusSourceAlpha`, and `As0` is equal to 1, the
    /// equations reduce to simple replacement:
    ///
    /// ```
    /// Rd = Rs0
    /// Gd = Gs0
    /// Bd = Bs0
    /// Ad = As0
    /// ```
    ///
    /// # Notes
    ///
    /// - When more than one color buffer is enabled for drawing the GL performs blending
    ///   separately for each enabled buffer, using the contents of that buffer for destination
    ///   color (See `draw_buffer`).
    /// - When dual source blending is enabled (i.e. one of the blend factors requiring the second
    ///   color input is used), the maximum number of enabled draw buffers is given by
    ///   `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS`, which may be lower than `GL_MAX_DRAW_BUFFERS`.
    fn blend_func(src_factor: SourceFactor, dest_factor: DestFactor));

gl_proc!(glBufferData:
    /// Creates and initializes a buffer object's data store.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glBufferData)
    ///
    /// Core since version 1.5
    ///
    /// Creates a new data store for the buffer object currently bound to target​. Any pre-existing
    /// data store is deleted. The new data store is created with the specified size​ in bytes and
    /// usage​. If data​ is not null, the data store is initialized with data from this pointer. In its
    /// initial state the new data store is not mapped, it has a null mapped pointer, and its mapped
    /// access is `GL_READ_WRITE`.
    ///
    /// # Buffer Usage
    ///
    /// `usage​` is a hint to the GL implementation as to how a buffer object's data store will be
    /// accessed. This enables the GL implementation to make more intelligent decisions that may
    /// significantly impact buffer object performance. It does not, however, constrain the actual
    /// usage of the data store. usage​ can be broken down into two parts: first, the frequency of
    /// access (modification and usage), and second, the nature of that access. The frequency of
    /// access may be one of these:
    ///
    /// - **STREAM** - The data store contents will be modified once and used at most a few times.
    /// - **STATIC** - The data store contents will be modified once and used many times.
    /// - **DYNAMIC** - The data store contents will be modified repeatedly and used many times.
    ///
    /// The nature of access may be one of these:
    ///
    /// - **DRAW** - The data store contents are modified by the application, and used as the source
    ///   for GL drawing and image specification commands.
    /// - **READ** - The data store contents are modified by reading data from the GL, and used to
    ///   return that data when queried by the application.
    /// - **COPY** - The data store contents are modified by reading data from the GL, and used as the
    ///   source for GL drawing and image specification commands.
    ///
    /// # Notes
    ///
    /// - If `data​` is null a data store of the specified size is still created but its contents remain
    ///   uninitialized and thus undefined.
    /// - Clients must align data elements consistent with the requirements of the client platform, with
    ///   an additional base-level requirement that an offset within a buffer to a datum comprising N
    ///   bytes be a multiple of N.
    /// - The `AtomicCounter` target is available only if the GL version is 4.2 or greater.
    /// - The `DispatchIndirect` and `ShaderStorage` targets are available only if the GL version is
    ///   4.3 or greater.
    /// - The `Query` target is available only if the GL version is 4.4 or greater.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if `size​` is negative.
    /// - `GL_INVALID_OPERATION` is generated if the reserved buffer object name 0 is bound to target​.
    /// - `GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store with the
    ///   specified size​.
    fn buffer_data_raw(target: BufferTarget, size: isize, data: *const (), usage: BufferUsage));

gl_proc!(glClear:
    /// Clears buffers to preset values.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glClear)
    ///
    /// Core since version 1.0
    ///
    /// Sets the bitplane area of the window to values previously selected by `clear_color`,
    /// `clear_depth`, and `clear_stencil`. Multiple color buffers can be cleared simultaneously by
    /// selecting more than one buffer at a time using `draw_buffers`.
    ///
    /// The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the
    /// operation of `clear`. The scissor box bounds the cleared region. Alpha function, blend
    /// function, logical operation, stenciling, texture mapping, and depth-buffering are ignored by
    /// `clear`.
    ///
    /// `clear` takes a single argument that is the bitwise OR of several values indicating which
    /// buffer is to be cleared.
    ///
    /// The values are as follows:
    ///
    /// - `ClearBufferMask::Color` - Indicates the buffers currently enabled for color writing.
    /// - `ClearBufferMask::Depth` - Indicates the depth buffer.
    /// - `ClearBufferMask::Stencil` - Indicates the stencil buffer.
    ///
    /// The value to which each buffer is cleared depends on the setting of the clear value for that
    /// buffer.
    ///
    /// # Notes
    ///
    /// - If a buffer is not present, then a `clear` call directed at that buffer has no effect.
    fn clear(mask: ClearBufferMask));

gl_proc!(glClearColor:
    fn clear_color(red: f32, green: f32, blue: f32, alpha: f32));

gl_proc!(glCompileShader:
    /// Compiles a shader object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glCompileShader)
    ///
    /// Core since version 2.0
    ///
    /// Compiles the source code strings that have been stored in the shader object specified
    /// by shader​.
    ///
    /// The compilation status will be stored as part of the shader object's state. This value
    /// will be set to `true` if the shader was compiled without errors and is ready for use,
    /// and `false` otherwise. It can be queried by calling `get_shader` with arguments `shader​`
    /// and `GL_COMPILE_STATUS`.
    ///
    /// Compilation of a shader can fail for a number of reasons as specified by the OpenGL
    /// Shading Language Specification. Whether or not the compilation was successful, information
    /// about the compilation can be obtained from the shader object's information log by
    /// calling `get_shader_info_log`.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if shader​ is not a value generated by OpenGL.
    fn compile_shader(shader: ShaderObject));

gl_proc!(glCreateProgram:
    /// Creates a program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glCreateProgram)
    ///
    /// Core since version 2.0
    ///
    /// Creates an empty program object and returns a non-zero value by which it can be
    /// referenced. A program object is an object to which shader objects can be attached.
    /// This provides a mechanism to specify the shader objects that will be linked to create a
    /// program. It also provides a means for checking the compatibility of the shaders that will
    /// be used to create a program (for instance, checking the compatibility between a vertex
    /// shader and a fragment shader). When no longer needed as part of a program object, shader
    /// objects can be detached.
    ///
    /// One or more executables are created in a program object by successfully attaching shader
    /// objects to it with `attach_shader`, successfully compiling the shader objects with
    /// `compile_shader`, and successfully linking the program object with `link_program`. These
    /// executables are made part of current state when `use_program` is called. Program objects
    /// can be deleted by calling `delete_program`. The memory associated with the program object
    /// will be deleted when it is no longer part of current rendering state for any context.
    ///
    /// # Notes
    ///
    /// - Like buffer and texture objects, the name space for program objects may be shared
    ///   across a set of contexts, as long as the server sides of the contexts share the same
    ///   address space. If the name space is shared across contexts, any attached objects and
    ///   the data associated with those attached objects are shared as well.
    /// - Applications are responsible for providing the synchronization across API calls when
    ///   objects are accessed from different execution threads.
    ///
    /// # Errors
    ///
    /// - This function returns 0 (the null program object) if an error occurs creating the
    ///   program object.
    fn create_program() -> ProgramObject);

gl_proc!(glCreateShader:
    /// Creates a shader object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glCreateShader)
    ///
    /// Core since version 2.0
    ///
    /// Creates an empty shader object and returns a non-zero value by which it can be referenced.
    /// A shader object is used to maintain the source code strings that define a shader.
    /// `shader_type` indicates the type of shader to be created. The following types are
    /// supported:
    ///
    /// - `VertexShader`
    /// - `TessControlShader`
    /// - `TessEvaluationShader`
    /// - `GeometryShader`
    /// - `FragmentShader`
    /// - `ComputeShader`
    ///
    /// When created, a shader object's `GL_SHADER_TYPE` parameter is set to the `shader_type`.
    ///
    /// # Notes
    ///
    /// - Like buffer and texture objects, the name space for shader objects may be shared across a
    ///   set of contexts, as long as the server sides of the contexts share the same address space.
    ///   If the name space is shared across contexts, any attached objects and the data associated
    ///   with those attached objects are shared as well.
    /// - Applications are responsible for providing the synchronization across API calls when
    ///   objects are accessed from different execution threads.
    /// - `ComputeShader` is available only if the GL version is 4.3 or higher.
    ///
    /// # Errors
    ///
    /// - This function returns 0 (the null shader object) if an error occurs creating the shader
    ///   object.
    fn create_shader(shader_type: ShaderType) -> ShaderObject);

gl_proc!(glCullFace:
    /// Specifies whether front- or back-faces should be culled.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glCullFace)
    ///
    /// Core since version 1.0
    ///
    /// Specifies whether front- or back-facing facets are culled (as specified by mode) when
    /// facet culling is enabled. Facet culling is initially disabled. To enable and disable facet
    /// culling, call `enable` and `disable` commands with the argument `CullFace`. Facets include
    /// triangles, quadrilaterals, polygons, and rectangles.
    ///
    /// `front_face` specifies which of the clockwise and counterclockwise facets are front-facing
    /// and back-facing.
    ///
    /// # Notes
    ///
    /// - If `mode​` is `FrontAndBack` no facets are drawn but other primitives such as points and
    ///   lines are drawn.
    fn cull_face(mode: Face));

gl_proc!(glDebugMessageCallback:
    fn debug_message_callback(
        callback: Option<DebugMessageCallback>,
        user_param: *mut ()
    ));

gl_proc!(glDeleteBuffers:
    /// Deletes named buffer objects.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glDeleteBuffers)
    ///
    /// Core since version 1.5
    ///
    /// Deletes n​ buffer objects named by the elements of the array buffers​. After a buffer object is
    /// deleted, it has no contents, and its name is free for reuse (for example by glGenBuffers​). If
    /// a buffer object that is currently bound is deleted, the binding reverts to 0 (the absence of
    /// any buffer object).
    ///
    /// glDeleteBuffers silently ignores 0's and names that do not correspond to existing buffer
    /// objects.
    ///
    /// # Errors
    ///
    /// `GL_INVALID_VALUE` is generated if `num_buffers` is negative.
    fn delete_buffers(num_buffers: i32, buffers: *const BufferName));

gl_proc!(glDeleteProgram:
    /// Deletes a program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glDeleteProgram)
    ///
    /// Core since version 2.0
    ///
    /// Frees the memory and invalidates the name associated with the program object specified by
    /// `program_object`.​ This command effectively undoes the effects of a call to
    /// `create_program`.
    ///
    /// If a program object is in use as part of current rendering state it will be flagged for
    /// deletion but it will not be deleted until it is no longer part of current state for any
    /// rendering context. If a program object to be deleted has shader objects attached to it
    /// those shader objects will be automatically detached but not deleted unless they have
    /// already been flagged for deletion by a previous call to `delete_shader`.
    ///
    /// A value of 0 (a "null" program object) for `program_object` will be silently ignored.
    ///
    /// To determine whether a program object has been flagged for deletion call
    /// `get_program_param` with arguments `program_object` and `DeleteStatus`.
    fn delete_program(program_object: ProgramObject));

gl_proc!(glDeleteShader:
    /// Deletes a shader object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glDeleteShader)
    ///
    /// Core since version 2.0
    ///
    /// Frees the memory and invalidates the name associated with the shader object specified by
    /// `shader_object`. This command effectively undoes the effects of a call to `create_shader`.
    ///
    /// If a shader object to be deleted is attached to a program object it will be flagged for
    /// deletion but it will not be deleted until it is no longer attached to any program object,
    /// for any rendering context (i.e., it must be detached from wherever it was attached before
    /// it will be deleted).
    ///
    /// To determine whether an object has been flagged for deletion call `get_shader_param` with
    /// arguments `shader_object` and `DeleteStatus`.
    fn delete_shader(shader_object: ShaderObject));

gl_proc!(glDeleteQueries:
    /// Deletes named query objects.
    ///
    /// [Official docs](https://www.opengl.org/sdk/docs/man/docbook4/xhtml/glDeleteQueries.xml)
    ///
    /// Core since version 1.5
    ///
    /// Deletes `count` query objects named by the elements of the array `queries`. After a
    /// query object is deleted, it has no contents, and its name is free for reuse (for
    /// example by `gen_queries()`).
    ///
    /// `delete_queries` silently ignores 0's and names that do not correspond to existing query
    /// objects. If one of the query objects to be deleted is currently active, the name becomes
    /// unused, but the underlying query object is not deleted until it is no longer active.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if `count` is negative.
    fn delete_queries(count: i32, queries: *const QueryObject));

gl_proc!(glDeleteTextures:
    /// Deletes named textures.
    ///
    /// Deletes `count` textures named by the elements of the array `textures​`. After a texture
    /// is deleted it has no contents or dimensionality and its name is free for reuse (for
    /// example by `gen_textures`). If a texture that is currently bound is deleted the binding
    /// reverts to 0 (the default texture).
    ///
    /// `delete_textures` silently ignores 0's and names that do not correspond to existing
    /// textures.
    fn delete_textures(count: u32, textures: *mut TextureObject));

gl_proc!(glDeleteVertexArrays:
    /// Deletes name vertex array objects.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glDeleteVertexArrays)
    ///
    /// Core since version 3.0
    ///
    /// Deletes n​ vertex array objects whose names are stored in the array addressed by arrays​. Once a
    /// vertex array object is deleted it has no contents and its name is again unused. If a vertex
    /// array object that is currently bound is deleted, the binding for that object reverts to zero
    /// and the default vertex array becomes current. Unused names in arrays​ are silently ignored, as
    /// is the value zero.
    ///
    /// # Errors
    ///
    /// `GL_INVALID_VALUE` is generated if `num_arrays`​ is negative.
    fn delete_vertex_arrays(num_arrays: i32, arrays: *const VertexArrayName));

gl_proc!(glDepthFunc:
    /// Specifies the value used for the depth buffer comparison.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glDepthFunc)
    ///
    /// Core since version 1.0
    ///
    /// Specifies the function used to compare each incoming pixel depth value with the depth
    /// value present in the depth buffer. The comparison is performed only if depth testing is
    /// enabled (see `enable` and `disable` of `DepthTest`).
    ///
    /// `func​` specifies the conditions under which the pixel will be drawn. The comparison
    /// functions are as follows:
    ///
    /// - `Never` - Never passes.
    /// - `Less` - Passes if the incoming depth value is less than the stored depth value.
    /// - `Equal` - Passes if the incoming depth value is equal to the stored depth value.
    /// - `LessThanOrEqual` - Passes if the incoming depth value is less than or equal to the
    ///   stored depth value.
    /// - `Greater` - Passes if the incoming depth value is greater than the stored depth value.
    /// - `NotEqual` - Passes if the incoming depth value is not equal to the stored depth value.
    /// - `GreaterThanOrEqual` - Passes if the incoming depth value is greater than or equal to
    ///   the stored depth value.
    /// - `Always` - Always passes.
    ///
    /// The initial value of `func​` is `Less`. Initially depth testing is disabled. If depth
    /// testing is disabled or if no depth buffer exists it is as if the depth test always passes.
    fn depth_func(func: Comparison));

gl_proc!(glDetachShader:
    /// Detaches a shader object from a program object to which it is attached.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glDetachShader)
    ///
    /// Cores since version 2.0
    ///
    /// Detaches the shader object specified by `shader​_object` from the program object specified
    /// by `program_object`. This command can be used to undo the effect of the command
    /// `attach_shader`.
    ///
    /// If `shader_object` has already been flagged for deletion by a call to `delete_shader` and
    /// it is not attached to any other program object it will be deleted after it has been
    /// detached.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_OPERATION` is generated if `shader​_object` is not attached to
    ///   `program​_object`.
    fn detach_shader(program_object: ProgramObject, shader_object: ShaderObject));

gl_proc!(glDisable:
    /// Disables server-side GL capabilities.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glEnable)
    ///
    /// Core since version 1.0
    ///
    /// Disables various server capabilities. Use `is_enabled` or `get` to determine the current
    /// setting of any capability. The initial value for each capability with the exception of
    /// `Diter` and `Multisample` is `false`. The initial value for `Dither` and `Multisample` is
    /// `true`.
    fn disable(capability: ServerCapability));

gl_proc!(glDisableVertexAttribArray:
    /// Disables a generic vertex attribute array.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glEnableVertexAttribArray)
    ///
    /// Core since version 2.0
    ///
    /// Disables the generic vertex attribute array specified by `attrib`. By default, all client-side
    /// capabilities are disabled, including all generic vertex attribute arrays. If enabled the
    /// values in the generic vertex attribute array will be accessed and used for rendering when
    /// calls are made to vertex array commands such as `draw_arrays`, `draw_elements`,
    /// `draw_range_elements`, `multi_draw_elements`, or `multi_draw_arrays`.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if the index represented by `attrib` is greater than or
    ///   equal to `GL_MAX_VERTEX_ATTRIBS`.
    /// - `GL_INVALID_OPERATION` is generated if no vertex array object is bound.
    fn disable_vertex_attrib_array(attrib: AttributeLocation));

gl_proc!(glDrawArrays:
    /// Renders primitives from array data.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glDrawArrays)
    ///
    /// Core since version 1.1
    ///
    /// Specifies multiple geometric primitives with very few subroutine calls. Instead of calling a
    /// GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color,
    /// you can prespecify separate arrays of vertices, normals, and colors and use them to construct
    /// a sequence of primitives with a single call to `draw_arrays`.
    ///
    /// When `draw_arrays` is called it uses `count​` sequential elements from each enabled array to
    /// construct a sequence of geometric primitives beginning with element `first​`. `mode​` specifies
    /// what kind of primitives are constructed and how the array elements construct those primitives.
    ///
    /// Vertex attributes that are modified by `draw_arrays` have an unspecified value after
    /// `draw_arrays` returns. Attributes that aren't modified remain well defined.
    ///
    /// # Notes
    ///
    /// - `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY`, and
    ///   `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if `count​` is negative.
    /// - `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled
    ///    array and the buffer object's data store is currently mapped.
    /// - `GL_INVALID_OPERATION` is generated if a geometry shader is active and mode​ is incompatible
    ///    with the input primitive type of the geometry shader in the currently installed program
    ///    object.
    fn draw_arrays(mode: DrawMode, first: i32, count: i32));

gl_proc!(glDrawElements:
    /// Renders primitives from array data.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glDrawElements)
    ///
    /// Core since version 1.1
    ///
    /// Specifies multiple geometric primitives with very few subroutine calls. Instead of calling
    /// a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or
    /// color, you can prespecify separate arrays of vertices, normals, and so on, and use them
    /// to construct a sequence of primitives with a single call to `draw_elements`.
    ///
    /// When `draw_elements` is called it uses `count​` sequential elements from an enabled array,
    /// starting at `offset` (interpreted as a byte count) to construct a sequence of geometric
    /// primitives. `mode​` specifies what kind of primitives are constructed and how the array
    /// elements construct these primitives. If more than one array is enabled, each is used.
    ///
    /// Vertex attributes that are modified by `draw_elements` have an unspecified value after
    /// `draw_elements` returns. Attributes that aren't modified maintain their previous values.
    ///
    /// # Notes
    ///
    /// - `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and
    ///   `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
    /// - `draw_elements` is included in display lists. If `draw_elements` is entered into a
    ///   display list the necessary array data (determined by the array pointers and enables)
    ///   is also entered into the display list. Because the array pointers and enables are
    ///   client-side state their values affect display lists when the lists are created, not
    ///   when the lists are executed.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if count​ is negative.
    /// - `GL_INVALID_OPERATION` is generated if a geometry shader is active and mode​ is
    ///   incompatible with the input primitive type of the geometry shader in the currently
    ///   installed program object.
    /// - `GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an
    ///   enabled array or the element array and the buffer object's data store is currently
    ///   mapped.
    fn draw_elements(mode: DrawMode, count: i32, index_type: IndexType, offset: usize));

gl_proc!(glEnable:
    /// Enables server-side GL capabilities.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glEnable)
    ///
    /// Core since version 1.0
    ///
    /// Enables various server capabilities. Use `is_enabled` or `get` to determine the current
    /// setting of any capability. The initial value for each capability with the exception of
    /// `Diter` and `Multisample` is `false`. The initial value for `Dither` and `Multisample` is
    /// `true`.
    fn enable(capability: ServerCapability));

gl_proc!(glEndQuery:
    /// Delimits the end of a query object.
    ///
    /// TODO: Add documentation.
    fn end_query(query_type: QueryType));

gl_proc!(glEnableVertexAttribArray:
    /// Enables a generic vertex attribute array.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glEnableVertexAttribArray)
    ///
    /// Core since version 2.0
    ///
    /// Enables the generic vertex attribute array specified by `attrib`. By default, all client-side
    /// capabilities are disabled, including all generic vertex attribute arrays. If enabled the
    /// values in the generic vertex attribute array will be accessed and used for rendering when
    /// calls are made to vertex array commands such as `draw_arrays`, `draw_elements`,
    /// `draw_range_elements`, `multi_draw_elements`, or `multi_draw_arrays`.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if the index represented by `attrib` is greater than or
    ///   equal to `GL_MAX_VERTEX_ATTRIBS`.
    /// - `GL_INVALID_OPERATION` is generated if no vertex array object is bound.
    fn enable_vertex_attrib_array(attrib: AttributeLocation));

gl_proc!(glFinish:
    /// TODO: Add documentation.
    fn finish());

gl_proc!(glFlush:
    /// TODO: Add documentation.
    fn flush());

gl_proc!(glFrontFace:
    /// Defines front- and back-facing polygons.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glFrontFace)
    ///
    /// Core since version 1.0
    ///
    /// In a scene composed entirely of opaque closed surfaces, back-facing polygons are never
    /// visible. Eliminating these invisible polygons has the obvious benefit of speeding up the
    /// rendering of the image. To enable and disable elimination of back-facing polygons, call
    /// `enable` and `disable` with argument `CullFace`.
    ///
    /// The projection of a polygon to window coordinates is said to have clockwise winding if an
    /// imaginary object following the path from its first vertex, its second vertex, and so on,
    /// to its last vertex, and finally back to its first vertex, moves in a clockwise direction
    /// about the interior of the polygon. The polygon's winding is said to be counterclockwise if
    /// the imaginary object following the same path moves in a counterclockwise direction about
    /// the interior of the polygon. `front_face` specifies whether polygons with clockwise
    /// winding in window coordinates, or counterclockwise winding in window coordinates, are
    /// taken to be front-facing. Passing `CounterClockwise` to `mode​` selects counterclockwise
    /// polygons as front-facing; `Clockwise` selects clockwise polygons as front-facing.
    /// By default counterclockwise polygons are taken to be front-facing.
    fn front_face(mode: WindingOrder));

gl_proc!(glGenBuffers:
    /// Generates buffer object names.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glGenBuffers)
    ///
    /// Core since version 1.5
    ///
    /// glGenBuffers returns n​ buffer object names in buffers​. There is no guarantee that the names
    /// form a contiguous set of integers; however, it is guaranteed that none of the returned names
    /// was in use immediately before the call to glGenBuffers.
    ///
    /// Buffer object names returned by a call to glGenBuffers are not returned by subsequent calls,
    /// unless they are first deleted with glDeleteBuffers​.
    ///
    /// No buffer objects are associated with the returned buffer object names until they are first
    /// bound by calling glBindBuffer​.
    ///
    /// # Errors
    ///
    /// `GL_INVALID_VALUE` is generated if `num_buffers`​ is negative.
    fn gen_buffers(num_buffers: i32, buffers: *mut BufferName));

gl_proc!(glGenTextures:
    /// Generates texture names.
    ///
    /// Returns `count`​ texture names in `textures​`. There is no guarantee that the names form a
    /// contiguous set of integers; however, it is guaranteed that none of the returned names
    /// was in use immediately before the call to `gen_textures`.
    ///
    /// The generated textures have no dimensionality; they assume the dimensionality of the
    /// texture target to which they are first bound (see `bind_texture`).
    ///
    /// Texture names returned by a call to `gen_textures` are not returned by subsequent calls,
    /// unless they are first deleted with `delete_textures`.
    fn gen_textures(count: u32, textures: *mut TextureObject));

gl_proc!(glGenQueries:
    /// Generates query object names.
    ///
    /// Returns `count` query object names in `queries`​. There is no guarantee that the names
    /// form a contiguous set of integers; however, it is guaranteed that none of the returned
    /// names was in use immediately before the call to `gen_queries()`.
    ///
    /// Query object names returned by a call to `gen_queries()` are not returned by subsequent
    /// calls, unless they are first deleted with `delete_queries()`.
    ///
    /// No query objects are associated with the returned query object names until they are first
    /// used by calling `begin_query()`.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if `count` is negative.
    fn gen_queries(count: i32, queries: *mut QueryObject));

gl_proc!(glGenVertexArrays:
    /// Generates vertex array object names.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glGenVertexArrays)
    ///
    /// Core since version 3.0
    ///
    /// Returns `num_arrays`​ vertex array object names in arrays​. There is no guarantee that the names
    /// form a contiguous set of integers; however, it is guaranteed that none of the returned names
    /// was in use immediately before the call to `gen_vertex_arrays`.
    ///
    /// Vertex array object names returned by a call to `gen_vertex_arrays` are not returned by
    /// subsequent calls, unless they are first deleted with `delete_vertex_arrays`.
    ///
    /// The names returned in arrays​ are marked as used, for the purposes of `gen_vertex_arrays` only,
    /// but they acquire state and type only when they are first bound.
    ///
    /// # Errors
    ///
    /// `GL_INVALID_VALUE` is generated if `num_arrays`​ is negative.
    fn gen_vertex_arrays(num_arrays: i32, arrays: *mut VertexArrayName));

gl_proc!(glGetAttribLocation:
    /// Returns the location of an attribute variable.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glGetAttribLocation)
    ///
    /// Core since 2.0
    ///
    /// Queries the previously linked program object specified by `program` for the attribute
    /// variable specified by `name` and returns the index of the generic vertex attribute that is
    /// bound to that attribute variable. If `name` is a matrix attribute variable, the index of
    /// the first column of the matrix is returned. If the named attribute variable is not an
    /// active attribute in the specified program object or if name starts with the reserved
    /// prefix "gl_" a value of -1 is returned.
    ///
    /// The association between an attribute variable name and a generic attribute index can be
    /// specified at any time by calling `bind_attrib_location`. Attribute bindings do not go
    /// into effect until `link_program` is called. After a program object has been linked
    /// successfully, the index values for attribute variables remain fixed until the next link
    /// command occurs. The attribute values can only be queried after a link if the link was
    /// successful. `get_attrib_location` returns the binding that actually went into effect the
    /// last time `link_program` was called for the specified program object. Attribute bindings
    /// that have been specified since the last link operation are not returned by
    /// `get_attrib_location`.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_OPERATION` is generated if `program` has not been successfully linked.
    fn get_attrib_location(program: ProgramObject, name: *const u8) -> i32);

gl_proc!(glGetInteger64v:
    /// Returns the value for simple state variables.
    ///
    /// TODO: Add documentation.
    fn get_i64v(name: Integer64Name, params: *mut i64));

gl_proc!(glGetIntegerv:
    /// Returns the value for simple state variables.
    ///
    /// These four commands return values for simple state variables in GL. `name` is a symbolic
    /// constant indicating the state variable to be returned, and params is a pointer to an
    /// array of the indicated type in which to place the returned data.
    ///
    /// Type conversion is performed if params has a different type than the state variable
    /// value being requested. If glGetBooleanv is called, a floating-point (or integer) value
    /// is converted to GL_FALSE if and only if it is 0.0 (or 0). Otherwise, it is converted to
    /// GL_TRUE. If glGetIntegerv is called, boolean values are returned as GL_TRUE or GL_FALSE,
    /// and most floating-point values are rounded to the nearest integer value. Floating-point
    /// colors and normals, however, are returned with a linear mapping that maps 1.0 to the
    /// most positive representable integer value and -1.0-1.0 to the most negative representable
    /// integer value. If glGetFloatv or glGetDoublev is called, boolean values are returned as
    ///  GL_TRUE or GL_FALSE, and integer values are converted to floating-point values.
    ///
    /// The following values for `name` are accepted:
    ///
    /// - `MajorVersion` - `params` returns one value, the major version number of the OpenGL API
    ///   supported by the current context.
    /// - `MinorVersion` - `params` returns one value, the minor version number of the OpenGL API
    ///   supported by the current context.
    /// - GL_NUM_EXTENSIONS - `params` returns one value, the number of extensions supported by
    ///   the GL implementation for the current context. See `get_string`.
    fn get_integers(name: IntegerName, params: *mut i32));

gl_proc!(glGetProgramInfoLog:
    /// Returns the information log for the program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glGetProgramInfoLog)
    ///
    /// Core since version 2.0
    ///
    /// Returns the information log for the specified program object. The information log for
    /// a program object is modified when the program object is linked or validated. The string
    /// that is returned will be null terminated.
    ///
    /// `get_program_info_log` returns in `log_out` as much of the information log as it can,
    /// up to a maximum of `max_length` characters. The number of characters actually returned,
    /// excluding the null termination character, is specified by `length_out`. If the length of
    /// the returned string is not required, a value of 0 can be passed in the length​ argument.
    /// The size of the buffer required to store the returned information log can be obtained by
    /// calling `get_program` with the value `InfoLogLength`.
    ///
    /// The information log for a program object is either an empty string, or a string
    /// containing information about the last link operation, or a string containing information
    /// about the last validation operation. It may contain diagnostic messages, warning
    /// messages, and other information. When a program object is created, its information log
    /// will be a string of length 0.
    ///
    /// # Notes
    ///
    /// - The information log for a program object is the OpenGL implementer's primary mechanism
    ///   for conveying information about linking and validating. Therefore, the information log
    ///   can be helpful to application developers during the development process, even when
    ///   these operations are successful. Application developers should not expect different
    ///   OpenGL implementations to produce identical information logs.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if program​ is not a value generated by OpenGL.
    /// - `GL_INVALID_OPERATION` is generated if program​ is not a program object.
    /// - `GL_INVALID_VALUE` is generated if `max_length` is less than 0.
    fn get_program_info_log(
        program: ProgramObject,
        max_length: i32,
        length_out: *mut i32,
        log_out: *mut u8));

gl_proc!(glGetProgramiv:
    /// Returns a parameter from a program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glGetProgram)
    ///
    /// Core since version 2.0
    ///
    /// Returns in `param_out` the value of a parameter for a specific program object. The
    /// following parameters are defined:
    ///
    /// - `DeleteStatus` - `param_out` returns `true` if program​ is currently flagged for
    ///   deletion, and `false` otherwise.
    /// - `LinkStatus` - `param_out` returns `true` if the last link operation on program​ was
    ///   successful, and `false` otherwise.
    /// - `ValidateStatus` - `param_out` returns `true` or if the last validation operation on
    ///   program​ was successful, and `false` otherwise.
    /// - `InfoLogLength` - `param_out` returns the number of characters in the information log
    ///   for program​ including the null termination character (i.e., the size of the character
    ///   buffer required to store the information log). If program​ has no information log, a
    ///   value of 0 is returned.
    /// - `AttachedShaders` - `param_out` returns the number of shader objects attached to program​.
    /// - `ActiveAtomicCounterBuffers` - `param_out` returns the number of active attribute
    ///   atomic counter buffers used by program​.
    /// - `ActiveAttributes` - `param_out` returns the number of active attribute variables
    ///   for program​.
    /// - `ActiveAttributeMaxLength` - `param_out` returns the length of the longest active
    ///   attribute name for program​, including the null termination character (i.e., the size of
    ///   the character buffer required to store the longest attribute name). If no active
    ///   attributes exist, 0 is returned.
    /// - `ActiveUniforms` - `param_out` returns the number of active uniform variables for program​.
    /// - `ActiveUniformMaxLength` - `param_out` returns the length of the longest active
    ///   uniform variable name for program​, including the null termination character (i.e., the
    ///   size of the character buffer required to store the longest uniform variable name). If
    ///   no active uniform variables exist, 0 is returned.
    /// - `ProgramBinaryLength` - `param_out` returns the length of the program binary, in bytes
    ///   that will be returned by a call to `get_program_binary`. When a progam's `LinkStatus`
    ///   is `false`, its program binary length is zero.
    /// - `ComputeWorkGroupSize` - `param_out` returns an array of three integers containing the
    ///   local work group size of the compute program as specified by its input layout
    ///   qualifier(s). program​ must be the name of a program object that has been previously
    ///   linked successfully and contains a binary for the compute shader stage.
    /// - `TransformFeedbackBufferMode` - `param_out` returns a symbolic constant indicating the
    ///   buffer mode used when transform feedback is active. This may be `SeparateAttribs`
    ///   or `InterleavedAttribs`.
    /// - `TransformFeedbackVaryings` - `param_out` returns the number of varying variables to
    ///   capture in transform feedback mode for the program.
    /// - `TransformFeedbackVaryingMaxLength` - `param_out` returns the length of the longest
    ///   variable name to be used for transform feedback, including the null-terminator.
    /// - `GeometryVerticesOut` - `param_out` returns the maximum number of vertices that the
    ///   geometry shader in program​ will output.
    /// - `GeometryInputType` - `param_out` returns a symbolic constant indicating the primitive
    ///   type accepted as input to the geometry shader contained in program​.
    /// - `GeometryOutputType` - `param_out` returns a symbolic constant indicating the primitive
    ///   type that will be output by the geometry shader contained in program​.
    ///
    /// # Notes
    ///
    /// - `ActiveUniformBlocks` and `ActiveUniformBlockMaxNameLength` are available only if the
    ///   GL version 3.1 or greater.
    /// - `GeometryVerticesOut`, `GeometryInputType` and `GeometryOutputType` are accepted only
    ///   if the GL version is 3.2 or greater.
    /// - `ComputeWorkGroupSize` is accepted only if the GL version is 4.3 or greater.
    /// - If an error is generated, no change is made to the contents of params​.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if program​ is not a value generated by OpenGL.
    /// - `GL_INVALID_OPERATION` is generated if program​ does not refer to a program object.
    /// - `GL_INVALID_OPERATION` is generated if `param_type` is `GeometryVerticesOut`,
    ///   `GeometryInputType`, or `GeometryOutputType`, and program​ does not contain a
    ///   geometry shader.
    /// - `GL_INVALID_OPERATION` is generated if `param_type` is `ComputeWorkGroupSize` and
    ///   program​ does not contain a binary for the compute shader stage.
    fn get_program_param(
        program: ProgramObject,
        param_type: ProgramParam,
        param_out: *mut i32));

gl_proc!(glGetQueryObjecti64v:
    /// Returns the parameters of a query object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glGetQueryObject)
    ///
    /// Core since version 3.3
    ///
    /// Returns in `params​` a selected parameter of the query object specified by `query`.
    ///
    /// TODO: Add documentation.
    fn get_query_object_i64v(query: QueryObject, result_type: QueryResultType, params: *mut i64));

gl_proc!(glGetQueryObjectui64v:
    /// Returns the parameters of a query object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glGetQueryObject)
    ///
    /// Core since version 3.3
    ///
    /// Returns in `params​` a selected parameter of the query object specified by `query`.
    ///
    /// TODO: Add documentation.
    fn get_query_object_u64v(query: QueryObject, result_type: QueryResultType, params: *mut u64));

gl_proc!(glGetShaderInfoLog:
    /// Returns the information log for a shader object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glGetShaderInfoLog)
    ///
    /// Core since version 2.0
    ///
    /// Returns the information log for the specified shader object. The information log for a
    /// shader object is modified when the shader is compiled. The string that is returned will
    /// be null terminated.
    ///
    /// `get_shader_info_log` returns in `log_out` as much of the information log as it can, up
    /// to a maximum of `max_length` characters. The number of characters actually returned,
    /// excluding the null termination character, is specified by `length_out`​. If the length of the
    /// returned string is not required, a value of 0 can be passed in the `length​_out` argument. The
    /// size of the buffer required to store the returned information log can be obtained by
    /// calling `get_shader` with the value `InfoLogLength`.
    ///
    /// The information log for a shader object is a string that may contain diagnostic messages,
    /// warning messages, and other information about the last compile operation. When a shader
    /// object is created, its information log will be a string of length 0.
    ///
    /// # Notes
    ///
    /// - The information log for a shader object is the OpenGL implementer's primary mechanism
    ///   for conveying information about the compilation process. Therefore, the information
    ///   log can be helpful to application developers during the development process, even when
    ///   compilation is successful. Application developers should not expect different OpenGL
    ///   implementations to produce identical information logs.
    ///
    /// # Errors
    ///
    /// - `InvalidValue` is generated if shader​ is not a value generated by OpenGL.
    /// - `InvalidOperation` is generated if shader​ is not a shader object.
    /// - `InvalidValue` is generated if maxLength​ is less than 0.
    fn get_shader_info_log(
        shader: ShaderObject,
        max_length: i32,
        length_out: *mut i32,
        log_out: *mut u8));

gl_proc!(glGetShaderiv:
    /// Returns a parameter from a shader object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glGetShader)
    ///
    /// Core since version 2.0
    ///
    /// glGetShader returns in params​ the value of a parameter for a specific shader object. The following parameters are defined:
    ///
    /// - `ShaderType` - params​ returns `VertexShader` if shader​ is a vertex shader object,
    ///   `GeometryShader` if shader​ is a geometry shader object, and `FragmentShader` if shader​
    ///   is a fragment shader object.
    /// - `DeleteStatus` - params​ returns `tre` if shader​ is currently flagged for deletion, and
    ///   `false` otherwise.
    /// - `CompileStatus` - params​ returns `true` if the last compile operation on shader​ was
    ///   successful, and `false` otherwise.
    /// - `InfoLogLength` - params​ returns the number of characters in the information log for
    ///   shader​ including the null termination character (i.e., the size of the character buffer
    ///   required to store the information log). If shader​ has no information log, a value of 0
    ///   is returned.
    /// - `ShaderSourceLength` - params​ returns the length of the concatenation of the source
    ///   strings that make up the shader source for the shader​, including the null termination
    ///   character. (i.e., the size of the character buffer required to store the shader source).
    ///   If no source code exists 0 is returned.
    ///
    /// # Notes
    ///
    /// - If an error is generated, no change is made to the contents of params​.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if shader​ is not a value generated by OpenGL.
    /// - `GL_INVALID_OPERATION` is generated if shader​ does not refer to a shader object.
    fn get_shader_param(shader: ShaderObject, param_type: ShaderParam, param_out: *mut i32));

gl_proc!(glGetString:
    /// Returns a string describing the current OpenGL.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glGetString)
    ///
    /// Core since version 1.0
    ///
    /// Returns a pointer to a static string describing some aspect of the current GL
    /// connection. name​ can be one of the following:
    /// - `Vendor` - Returns the company responsible for this GL implementation. This name does
    ///   not change from release to release.
    /// - `Renderer` - Returns the name of the renderer. This name is typically specific to a
    ///   particular configuration of a hardware platform. It does not change from release to
    ///   release.
    /// - `Version` - Returns a version or release number.
    /// - `ShadingLanguageVersion` - Returns a version or release number for the shading language.
    ///
    /// Strings `Vendor` and `Renderer` together uniquely specify a platform. They do not change
    /// from release to release and should be used by platform-recognition algorithms.
    ///
    /// The `Version` and `ShadingLanguageVersion` strings retrieved from `get_string()` begin
    /// with a version number. The version number uses one of these forms:
    ///
    /// ```
    /// major_number​.minor_number​
    /// ```
    ///
    /// or
    ///
    /// ```
    /// major_number​.minor_number​.release_number​
    /// ```
    ///
    /// Vendor-specific information may follow the version number. Its format depends on the
    /// implementation, but a space always separates the version number and the vendor-specific
    /// information.
    fn get_string(name: StringName) -> *const i8);

gl_proc!(glUniform1f:
    /// Specify the value of a uniform variable for the current program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glUniform)
    ///
    /// Core since version 2.0
    ///
    /// Modifies the value of a uniform variable. The location of the uniform variable to be
    /// modified is specified by `location​`, which should be a value returned by
    /// `get_uniform_location`​. `uniform_f32x1` operates on the program object that was made part
    /// of current state by calling `use_program`.
    ///
    /// The command `uniform_f32x1` is used to change the value of the uniform variable specified by
    /// `location​` using the value passed as arguments. The number specified in the command should
    /// match the number of components in the data type of the specified uniform variable (i.e.
    /// `uniform_f32x1` should be used to set a `float` variable).
    ///
    /// All active uniform variables defined in a program object are initialized to 0 when the
    /// program object is linked successfully. They retain the values assigned to them by a call
    /// to `uniform_*` until the next successful link operation occurs on the program object,
    /// when they are once again initialized to 0.
    ///
    /// # Notes
    ///
    /// - `uniform_i32x1` and `uniform_i32v` are the only two functions that may be used to load
    ///   uniform variables defined as opaque types. Loading opaque types with any other function
    ///   will result in a `GL_INVALID_OPERATION` error.
    /// - If count​ is greater than 1 and the indicated uniform variable is not an array, a
    ///   `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain
    ///   unchanged.
    /// - Other than the preceding exceptions, if the type and size of the uniform variable as
    ///   defined in the shader do not match the type and size specified in the name of the
    ///   command used to load its value, a `GL_INVALID_OPERATION` error will be generated and
    ///   the specified uniform variable will remain unchanged.
    /// - If `location​` is a value other than -1 and it does not represent a valid uniform variable
    ///   location in the current program object, an error will be generated, and no changes will
    ///   be made to the uniform variable storage of the current program object. If location​ is
    ///   equal to -1, the data passed in will be silently ignored and the specified uniform
    ///   variable will not be changed.
    fn uniform_f32x1(location: UniformLocation, value: f32));

gl_proc!(glUniform1fv:
    /// Specify the value of a uniform variable for the current program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glUniform)
    ///
    /// Core since version 2.0
    ///
    /// Modifies the value of a uniform variable. The location of the uniform variable to be
    /// modified is specified by `location​`, which should be a value returned by
    /// `get_uniform_location`​. `uniform_f32x1` operates on the program object that was made part
    /// of current state by calling `use_program`.
    ///
    /// The command `uniform_f32x4v` can be used to modify a single uniform variable or a uniform
    /// variable array. These commands pass a count and a pointer to the values to be loaded into
    /// a uniform variable or a uniform variable array. A count of 1 should be used if modifying
    /// the value of a single uniform variable, and a count of 1 or greater can be used to modify
    /// an entire array or part of an array. When loading n elements starting at an arbitrary
    /// position m in a uniform variable array, elements m + n - 1 in the array will be replaced
    /// with the new values. If m​ + n​ - 1 is larger than the size of the uniform variable array,
    /// values for all array elements beyond the end of the array will be ignored.
    ///
    /// The number of `f32` values pointed to by `data` should be 4 * `count`.
    ///
    /// All active uniform variables defined in a program object are initialized to 0 when the
    /// program object is linked successfully. They retain the values assigned to them by a call
    /// to `uniform_*` until the next successful link operation occurs on the program object,
    /// when they are once again initialized to 0.
    ///
    /// # Notes
    ///
    /// - `uniform_i32x1` and `uniform_i32v` are the only two functions that may be used to load
    ///   uniform variables defined as opaque types. Loading opaque types with any other function
    ///   will result in a `GL_INVALID_OPERATION` error.
    /// - If count​ is greater than 1 and the indicated uniform variable is not an array, a
    ///   `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain
    ///   unchanged.
    /// - Other than the preceding exceptions, if the type and size of the uniform variable as
    ///   defined in the shader do not match the type and size specified in the name of the
    ///   command used to load its value, a `GL_INVALID_OPERATION` error will be generated and
    ///   the specified uniform variable will remain unchanged.
    /// - If `location​` is a value other than -1 and it does not represent a valid uniform variable
    ///   location in the current program object, an error will be generated, and no changes will
    ///   be made to the uniform variable storage of the current program object. If location​ is
    ///   equal to -1, the data passed in will be silently ignored and the specified uniform
    ///   variable will not be changed.
    fn uniform_f32x1v(uniform: UniformLocation, count: i32, data: *const f32));

gl_proc!(glUniform1ui:
    /// Specify the value of a uniform variable for the current program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glUniform)
    ///
    /// Core since version 2.0
    ///
    /// Modifies the value of a uniform variable. The location of the uniform variable to be
    /// modified is specified by `location​`, which should be a value returned by
    /// `get_uniform_location()`​. `uniform_u32x1()` operates on the program object that was made part
    /// of current state by calling `use_program()`.
    ///
    /// The command `uniform_u32x1()` is used to change the value of the uniform variable specified by
    /// `location​` using the value passed as arguments. The number specified in the command should
    /// match the number of components in the data type of the specified uniform variable (i.e.
    /// `uniform_u32x1()` should be used to set a `uint` variable).
    ///
    /// All active uniform variables defined in a program object are initialized to 0 when the
    /// program object is linked successfully. They retain the values assigned to them by a call
    /// to `uniform_*` until the next successful link operation occurs on the program object,
    /// when they are once again initialized to 0.
    ///
    /// # Notes
    ///
    /// - `uniform_i32x1()` and `uniform_i32v()` are the only two functions that may be used to load
    ///   uniform variables defined as opaque types. Loading opaque types with any other function
    ///   will result in a `GL_INVALID_OPERATION` error.
    /// - If count​ is greater than 1 and the indicated uniform variable is not an array, a
    ///   `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain
    ///   unchanged.
    /// - Other than the preceding exceptions, if the type and size of the uniform variable as
    ///   defined in the shader do not match the type and size specified in the name of the
    ///   command used to load its value, a `GL_INVALID_OPERATION` error will be generated and
    ///   the specified uniform variable will remain unchanged.
    /// - If `location​` is a value other than -1 and it does not represent a valid uniform variable
    ///   location in the current program object, an error will be generated, and no changes will
    ///   be made to the uniform variable storage of the current program object. If location​ is
    ///   equal to -1, the data passed in will be silently ignored and the specified uniform
    ///   variable will not be changed.
    fn uniform_u32x1(location: UniformLocation, value: u32));

gl_proc!(glUniform2f:
    /// Specify the value of a uniform variable for the current program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glUniform)
    ///
    /// Core since version 2.0
    ///
    /// Modifies the value of a uniform variable. The location of the uniform variable to be
    /// modified is specified by `location​`, which should be a value returned by
    /// `get_uniform_location`​. `uniform_f32x2` operates on the program object that was made part
    /// of current state by calling `use_program`.
    ///
    /// The command `uniform_f32x2` is used to change the value of the uniform variable specified by
    /// `location​` using the value passed as arguments. The number specified in the command should
    /// match the number of components in the data type of the specified uniform variable (i.e.
    /// `uniform_f32x2` should be used to set a `vec2` variable).
    ///
    /// All active uniform variables defined in a program object are initialized to 0 when the
    /// program object is linked successfully. They retain the values assigned to them by a call
    /// to `uniform_*` until the next successful link operation occurs on the program object,
    /// when they are once again initialized to 0.
    ///
    /// # Notes
    ///
    /// - `uniform_i32x1` and `uniform_i32v` are the only two functions that may be used to load
    ///   uniform variables defined as opaque types. Loading opaque types with any other function
    ///   will result in a `GL_INVALID_OPERATION` error.
    /// - If count​ is greater than 1 and the indicated uniform variable is not an array, a
    ///   `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain
    ///   unchanged.
    /// - Other than the preceding exceptions, if the type and size of the uniform variable as
    ///   defined in the shader do not match the type and size specified in the name of the
    ///   command used to load its value, a `GL_INVALID_OPERATION` error will be generated and
    ///   the specified uniform variable will remain unchanged.
    /// - If `location​` is a value other than -1 and it does not represent a valid uniform variable
    ///   location in the current program object, an error will be generated, and no changes will
    ///   be made to the uniform variable storage of the current program object. If location​ is
    ///   equal to -1, the data passed in will be silently ignored and the specified uniform
    ///   variable will not be changed.
    fn uniform_f32x2(location: UniformLocation, x: f32, y: f32));

gl_proc!(glUniform3f:
    /// Specify the value of a uniform variable for the current program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glUniform)
    ///
    /// Core since version 2.0
    ///
    /// Modifies the value of a uniform variable. The location of the uniform variable to be
    /// modified is specified by `location​`, which should be a value returned by
    /// `get_uniform_location`​. `uniform_f32x3` operates on the program object that was made part
    /// of current state by calling `use_program`.
    ///
    /// The command `uniform_f32x4` is used to change the value of the uniform variable specified by
    /// `location​` using the value passed as arguments. The number specified in the command should
    /// match the number of components in the data type of the specified uniform variable (i.e.
    /// `uniform_f32x3` should be used to set a `vec3` variable).
    ///
    /// All active uniform variables defined in a program object are initialized to 0 when the
    /// program object is linked successfully. They retain the values assigned to them by a call
    /// to `uniform_*` until the next successful link operation occurs on the program object,
    /// when they are once again initialized to 0.
    ///
    /// # Notes
    ///
    /// - `uniform_i32x1` and `uniform_i32v` are the only two functions that may be used to load
    ///   uniform variables defined as opaque types. Loading opaque types with any other function
    ///   will result in a `GL_INVALID_OPERATION` error.
    /// - If count​ is greater than 1 and the indicated uniform variable is not an array, a
    ///   `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain
    ///   unchanged.
    /// - Other than the preceding exceptions, if the type and size of the uniform variable as
    ///   defined in the shader do not match the type and size specified in the name of the
    ///   command used to load its value, a `GL_INVALID_OPERATION` error will be generated and
    ///   the specified uniform variable will remain unchanged.
    /// - If `location​` is a value other than -1 and it does not represent a valid uniform variable
    ///   location in the current program object, an error will be generated, and no changes will
    ///   be made to the uniform variable storage of the current program object. If location​ is
    ///   equal to -1, the data passed in will be silently ignored and the specified uniform
    ///   variable will not be changed.
    fn uniform_f32x3(location: UniformLocation, x: f32, y: f32, z: f32));

gl_proc!(glUniform4f:
    /// Specify the value of a uniform variable for the current program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glUniform)
    ///
    /// Core since version 2.0
    ///
    /// Modifies the value of a uniform variable. The location of the uniform variable to be
    /// modified is specified by `location​`, which should be a value returned by
    /// `get_uniform_location`​. `uniform_f32x4` operates on the program object that was made part
    /// of current state by calling `use_program`.
    ///
    /// The command `uniform_f32x4` is used to change the value of the uniform variable specified by
    /// `location​` using the value passed as arguments. The number specified in the command should
    /// match the number of components in the data type of the specified uniform variable (i.e.
    /// `uniform_f32x4` should be used to set a `vec4` variable).
    ///
    /// All active uniform variables defined in a program object are initialized to 0 when the
    /// program object is linked successfully. They retain the values assigned to them by a call
    /// to `uniform_*` until the next successful link operation occurs on the program object,
    /// when they are once again initialized to 0.
    ///
    /// # Notes
    ///
    /// - `uniform_i32x1` and `uniform_i32v` are the only two functions that may be used to load
    ///   uniform variables defined as opaque types. Loading opaque types with any other function
    ///   will result in a `GL_INVALID_OPERATION` error.
    /// - If count​ is greater than 1 and the indicated uniform variable is not an array, a
    ///   `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain
    ///   unchanged.
    /// - Other than the preceding exceptions, if the type and size of the uniform variable as
    ///   defined in the shader do not match the type and size specified in the name of the
    ///   command used to load its value, a `GL_INVALID_OPERATION` error will be generated and
    ///   the specified uniform variable will remain unchanged.
    /// - If `location​` is a value other than -1 and it does not represent a valid uniform variable
    ///   location in the current program object, an error will be generated, and no changes will
    ///   be made to the uniform variable storage of the current program object. If location​ is
    ///   equal to -1, the data passed in will be silently ignored and the specified uniform
    ///   variable will not be changed.
    fn uniform_f32x4(location: UniformLocation, x: f32, y: f32, z: f32, w: f32));

gl_proc!(glUniform1i:
    /// Specify the value of a uniform variable for the current program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glUniform)
    ///
    /// Core since version 2.0
    ///
    /// Modifies the value of a uniform variable. The location of the uniform variable to be
    /// modified is specified by `location​`, which should be a value returned by
    /// `get_uniform_location`​. `uniform_i32x1` operates on the program object that was made part
    /// of current state by calling `use_program`.
    ///
    /// The command `uniform_i32x1` is changes the value of the uniform variable specified by
    /// `location​` using the value passed as arguments. The number specified in the command should
    /// match the number of components in the data type of the specified uniform variable (i.e.
    /// `uniform_i32x1` should be used to set an `int` or sampler variable).
    ///
    /// All active uniform variables defined in a program object are initialized to 0 when the
    /// program object is linked successfully. They retain the values assigned to them by a call
    /// to `uniform_*` until the next successful link operation occurs on the program object,
    /// when they are once again initialized to 0.
    ///
    /// # Notes
    ///
    /// - `uniform_i32x1` and `uniform_i32x1v` are the only two functions that may be used to load
    ///   uniform variables defined as opaque types. Loading opaque types with any other function
    ///   will result in a `GL_INVALID_OPERATION` error.
    /// - If count​ is greater than 1 and the indicated uniform variable is not an array, a
    ///   `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain
    ///   unchanged.
    /// - Other than the preceding exceptions, if the type and size of the uniform variable as
    ///   defined in the shader do not match the type and size specified in the name of the
    ///   command used to load its value, a `GL_INVALID_OPERATION` error will be generated and
    ///   the specified uniform variable will remain unchanged.
    /// - If `location​` is a value other than -1 and it does not represent a valid uniform variable
    ///   location in the current program object, an error will be generated, and no changes will
    ///   be made to the uniform variable storage of the current program object. If location​ is
    ///   equal to -1, the data passed in will be silently ignored and the specified uniform
    ///   variable will not be changed.
    fn uniform_i32x1(location: UniformLocation, value: i32));

gl_proc!(glUniform1iv:
    /// Specify the value of a uniform variable for the current program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glUniform)
    ///
    /// Core since version 2.0
    ///
    /// Modifies the value of a uniform variable. The location of the uniform variable to be
    /// modified is specified by `location​`, which should be a value returned by
    /// `get_uniform_location`​. `uniform_i32x1v` operates on the program object that was made part
    /// of current state by calling `use_program`.
    ///
    /// The command `uniform_i32x1v` can be used to modify a single uniform variable or a uniform
    /// variable array. This command passes a count and a pointer to the values to be loaded into
    /// a uniform variable or a uniform variable array. A count of 1 should be used if modifying
    /// the value of a single uniform variable, and a count of 1 or greater can be used to modify
    /// an entire array or part of an array. When loading n elements starting at an arbitrary
    /// position m in a uniform variable array, elements `m + n - 1` in the array will be replaced
    /// with the new values. If m`​ + n​ - 1` is larger than the size of the uniform variable array,
    /// values for all array elements beyond the end of the array will be ignored.
    ///
    /// All active uniform variables defined in a program object are initialized to 0 when the
    /// program object is linked successfully. They retain the values assigned to them by a call
    /// to `uniform_*` until the next successful link operation occurs on the program object,
    /// when they are once again initialized to 0.
    ///
    /// # Notes
    ///
    /// - `uniform_i32x1` and `uniform_i32x1v` are the only two functions that may be used to load
    ///   uniform variables defined as opaque types. Loading opaque types with any other function
    ///   will result in a `GL_INVALID_OPERATION` error.
    /// - If count​ is greater than 1 and the indicated uniform variable is not an array, a
    ///   `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain
    ///   unchanged.
    /// - Other than the preceding exceptions, if the type and size of the uniform variable as
    ///   defined in the shader do not match the type and size specified in the name of the
    ///   command used to load its value, a `GL_INVALID_OPERATION` error will be generated and
    ///   the specified uniform variable will remain unchanged.
    /// - If `location​` is a value other than -1 and it does not represent a valid uniform variable
    ///   location in the current program object, an error will be generated, and no changes will
    ///   be made to the uniform variable storage of the current program object. If location​ is
    ///   equal to -1, the data passed in will be silently ignored and the specified uniform
    ///   variable will not be changed.
    fn uniform_i32x1v(location: UniformLocation, count: i32, data: *const i32));

gl_proc!(glUniform3fv:
    /// Specify the value of a uniform variable for the current program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glUniform)
    ///
    /// Core since version 2.0
    ///
    /// Modifies the value of a uniform variable. The location of the uniform variable to be
    /// modified is specified by `location​`, which should be a value returned by
    /// `get_uniform_location`​. `uniform_f32x1` operates on the program object that was made part
    /// of current state by calling `use_program`.
    ///
    /// The command `uniform_f32x4v` can be used to modify a single uniform variable or a uniform
    /// variable array. These commands pass a count and a pointer to the values to be loaded into
    /// a uniform variable or a uniform variable array. A count of 1 should be used if modifying
    /// the value of a single uniform variable, and a count of 1 or greater can be used to modify
    /// an entire array or part of an array. When loading n elements starting at an arbitrary
    /// position m in a uniform variable array, elements m + n - 1 in the array will be replaced
    /// with the new values. If m​ + n​ - 1 is larger than the size of the uniform variable array,
    /// values for all array elements beyond the end of the array will be ignored.
    ///
    /// The number of `f32` values pointed to by `data` should be 4 * `count`.
    ///
    /// All active uniform variables defined in a program object are initialized to 0 when the
    /// program object is linked successfully. They retain the values assigned to them by a call
    /// to `uniform_*` until the next successful link operation occurs on the program object,
    /// when they are once again initialized to 0.
    ///
    /// # Notes
    ///
    /// - `uniform_i32x1` and `uniform_i32v` are the only two functions that may be used to load
    ///   uniform variables defined as opaque types. Loading opaque types with any other function
    ///   will result in a `GL_INVALID_OPERATION` error.
    /// - If count​ is greater than 1 and the indicated uniform variable is not an array, a
    ///   `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain
    ///   unchanged.
    /// - Other than the preceding exceptions, if the type and size of the uniform variable as
    ///   defined in the shader do not match the type and size specified in the name of the
    ///   command used to load its value, a `GL_INVALID_OPERATION` error will be generated and
    ///   the specified uniform variable will remain unchanged.
    /// - If `location​` is a value other than -1 and it does not represent a valid uniform variable
    ///   location in the current program object, an error will be generated, and no changes will
    ///   be made to the uniform variable storage of the current program object. If location​ is
    ///   equal to -1, the data passed in will be silently ignored and the specified uniform
    ///   variable will not be changed.
    fn uniform_f32x3v(uniform: UniformLocation, count: i32, data: *const f32));

gl_proc!(glUniform4fv:
    /// Specify the value of a uniform variable for the current program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glUniform)
    ///
    /// Core since version 2.0
    ///
    /// Modifies the value of a uniform variable. The location of the uniform variable to be
    /// modified is specified by `location​`, which should be a value returned by
    /// `get_uniform_location`​. `uniform_f32x1` operates on the program object that was made part
    /// of current state by calling `use_program`.
    ///
    /// The command `uniform_f32x4v` can be used to modify a single uniform variable or a uniform
    /// variable array. These commands pass a count and a pointer to the values to be loaded into
    /// a uniform variable or a uniform variable array. A count of 1 should be used if modifying
    /// the value of a single uniform variable, and a count of 1 or greater can be used to modify
    /// an entire array or part of an array. When loading n elements starting at an arbitrary
    /// position m in a uniform variable array, elements m + n - 1 in the array will be replaced
    /// with the new values. If m​ + n​ - 1 is larger than the size of the uniform variable array,
    /// values for all array elements beyond the end of the array will be ignored.
    ///
    /// The number of `f32` values pointed to by `data` should be 4 * `count`.
    ///
    /// All active uniform variables defined in a program object are initialized to 0 when the
    /// program object is linked successfully. They retain the values assigned to them by a call
    /// to `uniform_*` until the next successful link operation occurs on the program object,
    /// when they are once again initialized to 0.
    ///
    /// # Notes
    ///
    /// - `uniform_i32x1` and `uniform_i32v` are the only two functions that may be used to load
    ///   uniform variables defined as opaque types. Loading opaque types with any other function
    ///   will result in a `GL_INVALID_OPERATION` error.
    /// - If count​ is greater than 1 and the indicated uniform variable is not an array, a
    ///   `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain
    ///   unchanged.
    /// - Other than the preceding exceptions, if the type and size of the uniform variable as
    ///   defined in the shader do not match the type and size specified in the name of the
    ///   command used to load its value, a `GL_INVALID_OPERATION` error will be generated and
    ///   the specified uniform variable will remain unchanged.
    /// - If `location​` is a value other than -1 and it does not represent a valid uniform variable
    ///   location in the current program object, an error will be generated, and no changes will
    ///   be made to the uniform variable storage of the current program object. If location​ is
    ///   equal to -1, the data passed in will be silently ignored and the specified uniform
    ///   variable will not be changed.
    fn uniform_f32x4v(uniform: UniformLocation, count: i32, data: *const f32));

gl_proc!(glUniformMatrix4fv:
    /// Specify the value of a uniform variable for the current program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glUniform)
    ///
    /// Core since version 2.0
    ///
    /// Modifies the value of a uniform variable. The location of the uniform variable to be
    /// modified is specified by `location​`, which should be a value returned by
    /// `get_uniform_location`​. `uniform_matrix_f32x4v` operates on the program object that was
    /// made part of current state by calling `use_program`.
    ///
    /// The command `uniform_matrix_f32x4v` is used to modify a 4x4 matrix of `f32` values. If
    /// `transpose​` is `False` each matrix is assumed to be supplied in column major order. If
    /// transpose​ is `True` each matrix is assumed to be supplied in row major order. The `count​`
    /// argument indicates the number of matrices to be passed. A count of 1 should be used if
    /// modifying the value of a single matrix, and a count greater than 1 can be used to modify
    /// an array of matrices.
    ///
    /// All active uniform variables defined in a program object are initialized to 0 when the
    /// program object is linked successfully. They retain the values assigned to them by a call
    /// to `uniform_*` until the next successful link operation occurs on the program object,
    /// when they are once again initialized to 0.
    ///
    /// # Params
    ///
    /// - `location` - Specifies the location of the uniform value to be modified.
    /// - `count` - Specifies the number of matrices that are to be modified. This should be 1 if
    ///   the targeted uniform variable is not an array of matrices, and 1 or more if it is an
    ///   array of matrices.
    /// - `transpose` - Specifies whether to transpose the matrix as the values are loaded into
    ///   the uniform variable.
    /// - `values` - Specifies a pointer to an array of `count​` * 16 `f32` values that will be
    ///   used to update the specified uniform variable.
    ///
    /// # Notes
    ///
    /// - `uniform_i32x1` and `uniform_i32v` are the only two functions that may be used to load
    ///   uniform variables defined as opaque types. Loading opaque types with any other function
    ///   will result in a `GL_INVALID_OPERATION` error.
    /// - If count​ is greater than 1 and the indicated uniform variable is not an array, a
    ///   `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain
    ///   unchanged.
    /// - Other than the preceding exceptions, if the type and size of the uniform variable as
    ///   defined in the shader do not match the type and size specified in the name of the
    ///   command used to load its value, a `GL_INVALID_OPERATION` error will be generated and
    ///   the specified uniform variable will remain unchanged.
    /// - If `location​` is a value other than -1 and it does not represent a valid uniform variable
    ///   location in the current program object, an error will be generated, and no changes will
    ///   be made to the uniform variable storage of the current program object. If location​ is
    ///   equal to -1, the data passed in will be silently ignored and the specified uniform
    ///   variable will not be changed.
    fn uniform_matrix_f32x4v(
        uniform: UniformLocation,
        count: i32,
        transpose: Boolean,
        values: *const f32));

gl_proc!(glUniformMatrix3fv:
    /// Specify the value of a uniform variable for the current program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glUniform)
    ///
    /// Core since version 2.0
    ///
    /// Modifies the value of a uniform variable. The location of the uniform variable to be
    /// modified is specified by `location​`, which should be a value returned by
    /// `get_uniform_location`​. `uniform_matrix_f32x3v` operates on the program object that was
    /// made part of current state by calling `use_program`.
    ///
    /// The command `uniform_matrix_f32x3v` is used to modify a 3x3 matrix of `f32` values. If
    /// `transpose​` is `False` each matrix is assumed to be supplied in column major order. If
    /// transpose​ is `True` each matrix is assumed to be supplied in row major order. The `count​`
    /// argument indicates the number of matrices to be passed. A count of 1 should be used if
    /// modifying the value of a single matrix, and a count greater than 1 can be used to modify
    /// an array of matrices.
    ///
    /// All active uniform variables defined in a program object are initialized to 0 when the
    /// program object is linked successfully. They retain the values assigned to them by a call
    /// to `uniform_*` until the next successful link operation occurs on the program object,
    /// when they are once again initialized to 0.
    ///
    /// # Params
    ///
    /// - `location` - Specifies the location of the uniform value to be modified.
    /// - `count` - Specifies the number of matrices that are to be modified. This should be 1 if
    ///   the targeted uniform variable is not an array of matrices, and 1 or more if it is an
    ///   array of matrices.
    /// - `transpose` - Specifies whether to transpose the matrix as the values are loaded into
    ///   the uniform variable.
    /// - `values` - Specifies a pointer to an array of `count​` * 16 `f32` values that will be
    ///   used to update the specified uniform variable.
    ///
    /// # Notes
    ///
    /// - `uniform_i32x1` and `uniform_i32v` are the only two functions that may be used to load
    ///   uniform variables defined as opaque types. Loading opaque types with any other function
    ///   will result in a `GL_INVALID_OPERATION` error.
    /// - If count​ is greater than 1 and the indicated uniform variable is not an array, a
    ///   `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain
    ///   unchanged.
    /// - Other than the preceding exceptions, if the type and size of the uniform variable as
    ///   defined in the shader do not match the type and size specified in the name of the
    ///   command used to load its value, a `GL_INVALID_OPERATION` error will be generated and
    ///   the specified uniform variable will remain unchanged.
    /// - If `location​` is a value other than -1 and it does not represent a valid uniform variable
    ///   location in the current program object, an error will be generated, and no changes will
    ///   be made to the uniform variable storage of the current program object. If location​ is
    ///   equal to -1, the data passed in will be silently ignored and the specified uniform
    ///   variable will not be changed.
    fn uniform_matrix_f32x3v(
        uniform: UniformLocation,
        count: i32,
        transpose: Boolean,
        values: *const f32));

gl_proc!(glGetUniformLocation:
    /// Returns the location of a uniform variable.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glGetUniformLocation)
    ///
    /// Core since verion 2.0
    ///
    /// Returns an integer that represents the location of a specific uniform variable within a
    /// program object. name must be a null terminated string that contains no white space. name
    /// must be an active uniform variable name in program that is not a structure, an array of
    /// structures, or a subcomponent of a vector or a matrix. This function returns -1 if name
    /// does not correspond to an active uniform variable in program, if name starts with the
    /// reserved prefix "gl_", or if name is associated with an atomic counter or a named
    /// uniform block.
    ///
    /// Uniform variables that are structures or arrays of structures may be queried by calling
    /// `get_uniform_location_raw` for each field within the structure. The array element
    /// operator "[]" and the structure field operator "." may be used in name in order to select
    /// elements within an array or fields within a structure. The result of using these
    /// operators is not allowed to be another structure, an array of structures, or a
    /// subcomponent of a vector or a matrix. Except if the last part of name indicates a
    /// uniform variable array, the location of the first element of an array can be retrieved
    /// by using the name of the array, or by using the name appended by "[0]".
    ///
    /// The actual locations assigned to uniform variables are not known until the program object
    /// is linked successfully. After linking has occurred, the command `get_uniform_location_raw`
    /// can be used to obtain the location of a uniform variable. This location value can then be
    /// passed to the `uniform_*` functions to set the value of the uniform variable or to
    /// `get_uniform` in order to query the current value of the uniform variable. After a program
    /// object has been linked successfully, the index values for uniform variables remain fixed
    /// until the next link command occurs. Uniform variable locations and values can only be
    /// queried after a link if the link was successful.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if program is not a value generated by OpenGL.
    /// - `GL_INVALID_OPERATION` is generated if program is not a program object.
    /// - `GL_INVALID_OPERATION` is generated if program has not been successfully linked.
    fn get_uniform_location(program: ProgramObject, uniform_name: *const u8) -> i32);

gl_proc!(glLinkProgram:
    /// Links a program object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glLinkProgram)
    ///
    /// Core since version 2.0
    ///
    /// Links the program object specified by `program​`. If any shader objects of type
    /// `VertexShader` are attached to `program​`, they will be used to create an executable that
    /// will run on the programmable vertex processor. If any shader objects of type
    /// `GeometryShader` are attached to `program​`, they will be used to create an executable that
    /// will run on the programmable geometry processor. If any shader objects of type
    /// `FragmentShader` are attached to `program​`, they will be used to create an executable that
    /// will run on the programmable fragment processor.
    ///
    /// The status of the link operation will be stored as part of the program object's state.
    /// This value will be set to `true` if the program object was linked without errors and is
    /// ready for use, and `false` otherwise. It can be queried by calling `get_program` with
    /// arguments program​ and `LinkStatus`.
    ///
    /// As a result of a successful link operation, all active user-defined uniform variables
    /// belonging to program​ will be initialized to 0, and each of the program object's active
    /// uniform variables will be assigned a location that can be queried by calling
    /// `get_uniform_location`. Also, any active user-defined attribute variables that have not
    /// been bound to a generic vertex attribute index will be bound to one at this time.
    ///
    /// Linking of a program object can fail for a number of reasons as specified in the OpenGL
    /// Shading Language Specification. The following lists some of the conditions that will
    /// cause a link error.
    ///
    /// - The number of active attribute variables supported by the implementation has been
    ///   exceeded.
    /// - The storage limit for uniform variables has been exceeded.
    /// - The number of active uniform variables supported by the implementation has been exceeded.
    /// - The main function is missing for the vertex, geometry or fragment shader.
    /// - A varying variable actually used in the fragment shader is not declared in the same way
    ///   (or is not declared at all) in the vertex shader, or geometry shader shader if present.
    /// - A reference to a function or variable name is unresolved.
    /// - A shared global is declared with two different types or two different initial values.
    /// - One or more of the attached shader objects has not been successfully compiled.
    /// - Binding a generic attribute matrix caused some rows of the matrix to fall outside the
    ///   allowed maximum of `GL_MAX_VERTEX_ATTRIBS`.
    /// - Not enough contiguous vertex attribute slots could be found to bind attribute matrices.
    /// - The program object contains objects to form a fragment shader but does not contain
    ///   objects to form a vertex shader.
    /// - The program object contains objects to form a geometry shader but does not contain
    ///   objects to form a vertex shader.
    /// - The program object contains objects to form a geometry shader and the input primitive
    ///   type, output primitive type, or maximum output vertex count is not specified in any
    ///   compiled geometry shader object.
    /// - The program object contains objects to form a geometry shader and the input primitive
    ///   type, output primitive type, or maximum output vertex count is specified differently
    ///   in multiple geometry shader objects.
    /// - The number of active outputs in the fragment shader is greater than the value of
    ///   `GL_MAX_DRAW_BUFFERS`.
    /// - The program has an active output assigned to a location greater than or equal to the
    ///   value of `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS` and has an active output assigned an index
    ///   greater than or equal to one.
    /// - More than one varying out variable is bound to the same number and index.
    /// - The explicit binding assigments do not leave enough space for the linker to
    ///   automatically assign a location for a varying out array, which requires multiple
    ///   contiguous locations.
    /// - The count​ specified by glTransformFeedbackVaryings​ is non-zero, but the program object
    ///   has no vertex or geometry shader.
    /// - Any variable name specified to `transform_feedback_varyings` in the varyings​ array is
    ///   not declared as an output in the vertex shader (or the geometry shader, if active).
    /// - Any two entries in the varyings​ array given `transform_feedback_varyings` specify the
    ///   same varying variable.
    /// - The total number of components to capture in any transform feedback varying variable
    ///   is greater than the constant `GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS` and the
    ///   buffer mode is `GL_SEPARATE_ATTRIBS`.
    /// - When a program object has been successfully linked, the program object can be made
    ///   part of current state by calling `use_program`. Whether or not the link operation was
    ///   successful, the program object's information log will be overwritten. The information
    ///   log can be retrieved by calling `get_program_info_log`.
    ///
    /// `link_program` will also install the generated executables as part of the current
    /// rendering state if the link operation was successful and the specified program object is
    /// already currently in use as a result of a previous call to `use_program`. If the program
    /// object currently in use is relinked unsuccessfully, its link status will be set to
    /// `false`, but the executables and associated state will remain part of the current state
    /// until a subsequent call to `use_program` removes it from use. After it is removed from
    /// use, it cannot be made part of current state until it has been successfully relinked.
    ///
    /// If program​ contains shader objects of type `VertexShader`, and optionally of type
    /// `GeometryShader`, but does not contain shader objects of type `FragmentShader`, the
    /// vertex shader executable will be installed on the programmable vertex processor, the
    /// geometry shader executable, if present, will be installed on the programmable geometry
    /// processor, but no executable will be installed on the fragment processor. The results of
    /// rasterizing primitives with such a program will be undefined.
    ///
    /// The program object's information log is updated and the program is generated at the time
    /// of the link operation. After the link operation, applications are free to modify attached
    /// shader objects, compile attached shader objects, detach shader objects, delete shader
    /// objects, and attach additional shader objects. None of these operations affects the
    /// information log or the program that is part of the program object.
    ///
    /// # Notes
    ///
    /// - If the link operation is unsuccessful any information about a previous link operation
    ///   on program​ is lost (i.e., a failed link does not restore the old state of program​ ).
    ///   Certain information can still be retrieved from program​ even after an unsuccessful
    ///   link operation. See for instance `get_active_attrib` and `get_active_uniform`.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if program​ is not a value generated by OpenGL.
    /// - `GL_INVALID_OPERATION` is generated if program​ is not a program object.
    /// - `GL_INVALID_OPERATION` is generated if program​ is the currently active program object
    ///   and transform feedback mode is active.
    fn link_program(program: ProgramObject));

gl_proc!(glObjectLabel:
    /// Labels a named object for use in debug messages.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glObjectLabel)
    ///
    /// Core since version 4.3
    ///
    /// Labels the object identified by `name​` within the namespace given by `identifier​`.
    ///
    /// `label​` points to a string that will be used to label the object. `length​` contains the
    /// number of characters in `label​`. If `length​` is negative, it is implied that label​
    /// contains a null-terminated string. If label​ is `NULL`, any debug label is effectively
    /// removed from the object.
    fn set_object_label(identifier: DebugMessageId, name: u32, length: i32, label: u8));

gl_proc!(glPolygonMode:
    /// Selects the polygon rasterization mode.
    ///
    /// [Wiki page](http://docs.gl/gl2/glPolygonMode)
    ///
    /// Core since version 1.0
    ///
    /// Controls the interpretation of polygons for rasterization. `face`​ describes which polygons
    /// mode​ applies to: The polygon mode affects only the final rasterization of polygons. In
    /// particular, a polygon's vertices are lit and the polygon is clipped and possibly culled
    /// before these modes are applied.
    ///
    /// Three modes are defined and can be specified in mode​:
    ///
    /// - `Point` - Polygon vertices that are marked as the start of a boundary edge are drawn as
    ///   points. Point attributes such as `GL_POINT_SIZE` and `GL_POINT_SMOOTH` control the
    ///   rasterization of the points. Polygon rasterization attributes other than
    ///   `GL_POLYGON_MODE` have no effect.
    /// - `Line` - Boundary edges of the polygon are drawn as line segments. Line attributes such
    ///    as `GL_LINE_WIDTH` and `GL_LINE_SMOOTH` control the rasterization of the lines. Polygon
    ///    rasterization attributes other than `GL_POLYGON_MODE` have no effect.
    /// - `Fill` - The interior of the polygon is filled. Polygon attributes such as
    ///   `GL_POLYGON_SMOOTH` control the rasterization of the polygon.
    ///
    /// # Notes
    ///
    /// Vertices are marked as boundary or nonboundary with an edge flag. Edge flags are generated
    /// internally by the GL when it decomposes polygons; they can be set explicitly using
    /// `edge_flag`.
    fn polygon_mode(face: Face, mode: PolygonMode));

gl_proc!(glQueryCounter:
    /// Records the GL time into a query object after all previous commands have reached the GL
    /// server.
    ///
    /// [Official docs](https://www.opengl.org/sdk/docs/man4/html/glQueryCounter.xhtml)
    ///
    /// Core since version 3.3
    ///
    /// Causes the GL to record the current time into the query object named `query`. The time
    /// is recorded after all previous commands on the GL client and server state and the
    /// framebuffer have been fully realized. When the time is recorded, the query result for
    /// that object is marked available. `query_counter()` timer queries can be used within a
    /// `begin_query()` / `end_query()` block where the target is `TimeElapsed` and it does not
    /// affect the result of that query object.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_OPERATION` is generated if `query` is the name of a query object that is
    ///   already in use within a `begin_query()` / `end_query()` block.
    /// - `GL_INVALID_VALUE` is generated if `query` is not the name of a query object returned
    ///   from a previous call to `gen_queries()`.
    fn query_counter(query: QueryObject, target: QueryCounterTarget));

gl_proc!(glShaderSource:
    /// Replaces the source code in a shader object.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glShaderSource)
    ///
    /// Core since version 2.0
    ///
    /// Sets the source code in `shader​` to the source code in the array of strings specified by
    /// `string​s`. Any source code previously stored in the shader object is completely replaced.
    /// The number of strings in the array is specified by count​. If length​ is null, each string
    /// is assumed to be null terminated. If length​ is a value other than 0, it points to an
    /// array containing a string length for each of the corresponding elements of string​. Each
    /// element in the length​ array may contain the length of the corresponding string (the null
    /// character is not counted as part of the string length) or a value less than 0 to indicate
    /// that the string is null terminated. The source code strings are not scanned or parsed at
    /// this time; they are simply copied into the specified shader object.
    ///
    /// # Notes
    ///
    /// - OpenGL copies the shader source code strings when glShaderSource is called, so an
    ///   application may free its copy of the source code strings immediately after the function
    ///   returns.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_OPERATION` is generated if shader​ is not a shader object.
    /// - `GL_INVALID_VALUE` is generated if count​ is less than 0.
    fn shader_source(
        shader: ShaderObject,
        count: i32,
        strings: *const *const u8,
        length: *const i32));

gl_proc!(glTexImage2D:
    /// Specifies a two-dimensional texture image.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glTexImage2D)
    ///
    /// Core since version 1.0
    ///
    /// Texturing allows elements of an image array to be read by shaders.
    ///
    /// To define texture images, call `tex_image_2d`. The arguments describe the parameters of
    /// the texture image, such as height, width, width of the border, level-of-detail number
    /// (see `tex_parameter`), and number of color components provided. The last three arguments
    /// describe how the image is represented in memory.
    ///
    /// If target​ is `ProxyTexture2d`, `ProxyTexture1dArray`, `ProxyTextureCubeMap`, or
    /// `ProxyTextureRectangle`, no data is read from data​, but all of the texture image state
    /// is recalculated, checked for consistency, and checked against the implementation's
    /// capabilities. If the implementation cannot handle a texture of the requested texture
    /// size, it sets all of the image state to 0, but does not generate an error (see
    /// `get_error`). To query for an entire mipmap array, use an image array level greater than
    /// or equal to 1.
    ///
    /// If target​ is `Texture2d`, `TextureRectangle` or one of the `TextureCubeMap` targets, data
    /// is read from `data​` as a sequence of signed or unsigned bytes, shorts, or longs, or
    /// single-precision floating-point values, depending on type​. These values are grouped into
    /// sets of one, two, three, or four values, depending on format​, to form elements. Each
    /// byte in `data` is treated as eight 1-bit elements, with bit ordering determined by `UnpackLsbFirst`
    /// (see `pixel_store`).
    ///
    /// If target​ is `Texture1dArray`, data is interpreted as an array of one-dimensional images.
    ///
    /// If a non-zero named buffer object is bound to the `PixelUnpackBuffer` target (see
    /// `bind_buffer`) while a texture image is specified, data​ is treated as a byte offset into
    /// the buffer object's data store.
    ///
    /// The first element corresponds to the lower left corner of the texture image. Subsequent
    /// elements progress left-to-right through the remaining texels in the lowest row of the
    /// texture image, and then in successively higher rows of the texture image. The final
    /// element corresponds to the upper right corner of the texture image.
    ///
    /// format​ determines the composition of each element in data​. It can assume one of these
    /// symbolic values:
    ///
    /// - `Red` - Each element is a single red component. The GL converts it to floating point
    ///   and assembles it into an RGBA element by attaching 0 for green and blue, and 1 for
    ///   alpha. Each component is clamped to the range [0,1].
    /// - `Rg` - Each element is a red/green double. The GL converts it to floating point and
    ///   assembles it into an RGBA element by attaching 0 for blue, and 1 for alpha. Each
    ///   component is clamped to the range [0,1].
    /// - `Rgb`, `Bgr` - Each element is an RGB (or BGR) triple. The GL converts it to floating point and
    ///   assembles it into an RGBA element by attaching 1 for alpha. Each component is clamped
    ///   to the range [0,1].
    /// - `Rgba`, `Bgra` - Each element contains all four components. Each component is clamped
    ///   to the range [0,1].
    /// - `DepthComponent` - Each element is a single depth value. The GL converts it to floating
    ///   point and clamps to the range [0,1].
    /// - `DepthStencil` - Each element is a pair of depth and stencil values. The depth
    ///   component of the pair is interpreted as in `DepthComponent`. The stencil component is
    ///   interpreted based on specified the depth + stencil internal format.
    ///
    /// If an application wants to store the texture at a certain resolution or in a certain
    /// format, it can request the resolution and format with internalFormat​. The GL will choose
    /// an internal representation that closely approximates that requested by internalFormat​,
    /// but it may not match exactly. (The representations specified by `Red`, `Rg`, `Rgb`, and
    /// `Rgba` must match exactly.)
    ///
    /// `internal_format` may be one of the formats from the tables below:
    ///
    /// > TODO: Add tables. Blech that's a lot of info to copy in.
    ///
    /// # Parameters
    ///
    /// * `target` - Specifies the target texture.
    /// * `level` - Specifies the level-of-detail number. Level 0 is the base image level. Level
    ///   n is the nth mipmap reduction image. If target​ is `TextureRectangle` or
    ///   `ProxyTextureRectangle`, `level​` must be 0.
    /// * `internal_format` - Specifies the number of color components in the texture. Must be
    ///   one of base internal formats given in Table 1, one of the sized internal formats given
    ///   in Table 2, or one of the compressed internal formats given in Table 3, below.
    /// * `width` - Specifies the width of the texture image. All implementations support texture
    ///   images that are at least 1024 texels wide.
    /// * `height` - Specifies the height of the texture image, or the number of layers in a
    ///   texture array, in the case of the `Texture1dArray` and `ProxyTexture1dArray` targets.
    ///   All implementations support 2D texture images that are at least 1024 texels high, and
    ///   texture arrays that are at least 256 layers deep.
    /// * `border` - This value must be 0.
    /// * `format` - Specifies the format of the pixel data. For transfers of depth, stencil, or
    ///   depth/stencil data, you must use `DepthComponent`, `StencilIndex`, or `DepthStencil`,
    ///   where appropriate. For transfers of normalized integer or floating-point color image
    ///   data, you must use one of the following: `Red`, `Green`, `Blue`, `Rg`, `Rgb`, `Bgr`,
    ///   `Rgba`, and `Bgra`. For transfers of non-normalized integer data, you must use one of
    ///   the following: `RedInteger`, `GreenInteger`, `BlueInteger`, `RgInteger`, `RgbInteger`,
    ///   `BgrInteger`, `RgbaInteger`, and `BgraInteger`.
    /// * `type` - Specifies the data type of the pixel data.
    /// * `data` - Specifies a pointer to the image data in memory, or if a buffer is bound to
    ///   `PixelUnpackBuffer`, this provides an integer offset into the bound buffer object. If
    ///   a buffer is not bound to `PixelUnpackBuffer`, and this parameter is NULL, no
    ///   Pixel Transfer will be performed.
    fn texture_image_2d(
        target: Texture2dTarget,
        level: i32,
        internal_format: TextureInternalFormat,
        width: i32,
        height: i32,
        border: i32,
        format: TextureFormat,
        data_type: TextureDataType,
        data: *const ()));

gl_proc!(glTexParameteri:
    /// Sets texture parameters.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glTexParameter)
    ///
    /// Core since version 1.0
    ///
    /// TODO: Ugh the docs for this one are annoying.
    fn texture_parameter_i32(
        target: TextureParameterTarget,
        name: TextureParameterName,
        param: i32));

gl_proc!(glUseProgram:
    /// Installs a program as part of the current rendering state.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glUseProgram)
    ///
    /// Core since version 2.0
    ///
    /// Installs the program object specified by `program​` as part of current rendering state.
    /// One or more executables are created in a program object by successfully attaching shader
    /// objects to it with `attach_shader`, successfully compiling the shader objects with
    /// `compile_shader`, and successfully linking the program object with `link_program`.
    ///
    /// A program object will contain an executable that will run on the vertex processor if it
    /// contains one or more shader objects of type `VertexShader` that have been successfully
    /// compiled and linked. A program object will contain an executable that will run on the
    /// geometry processor if it contains one or more shader objects of type `GeometryShader` that
    /// have been successfully compiled and linked. Similarly, a program object will contain an
    /// executable that will run on the fragment processor if it contains one or more shader
    /// objects of type `FragmentShader` that have been successfully compiled and linked.
    ///
    /// While a program object is in use, applications are free to modify attached shader
    /// objects, compile attached shader objects, attach additional shader objects, and detach
    /// or delete shader objects. None of these operations will affect the executables that are
    /// part of the current state. However, relinking the program object that is currently in
    /// use will install the program object as part of the current rendering state if the link
    /// operation was successful (see `link_program`). If the program object currently in use is
    /// relinked unsuccessfully, its link status will be set to `false`, but the executables and
    /// associated state will remain part of the current state until a subsequent call to
    /// `use_program` removes it from use. After it is removed from use, it cannot be made part
    /// of current state until it has been successfully relinked.
    ///
    /// If `program​` is zero (the null program object), then the current rendering state refers to
    /// an invalid program object and the results of shader execution are undefined. However, this
    /// is not an error.
    ///
    /// If program​ does not contain shader objects of type `FragmentShader`, an executable will
    /// be installed on the vertex, and possibly geometry processors, but the results of fragment
    /// shader execution will be undefined.
    ///
    /// # Notes
    ///
    /// - Like buffer and texture objects, the name space for program objects may be shared
    ///   across a set of contexts, as long as the server sides of the contexts share the same
    ///   address space. If the name space is shared across contexts, any attached objects and
    ///   the data associated with those attached objects are shared as well.
    /// - Applications are responsible for providing the synchronization across API calls when
    ///   objects are accessed from different execution threads.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if program​ is neither 0 nor a value generated by OpenGL.
    /// - `GL_INVALID_OPERATION` is generated if program​ is not a program object.
    /// - `GL_INVALID_OPERATION` is generated if program​'s most recent link operation was not
    ///   successful.
    /// - `GL_INVALID_OPERATION` is generated if transform feedback mode is active.
    fn use_program(program: ProgramObject));

gl_proc!(glVertexAttribPointer:
    /// Defines an array of generic vertex attribute data.
    ///
    /// [Wiki page](https://www.opengl.org/wiki/GLAPI/glVertexAttribPointer)
    ///
    /// Core since version 2.0
    ///
    /// Specifies the location and data format of the array of generic vertex attributes to use when
    /// rendering.
    ///
    /// If `normalize` is set to `true` it indicates that values stored in an integer format are to be
    /// mapped to the range [-1,1] (for signed values) or [0,1] (for unsigned values) when they are
    /// accessed and converted to floating point. Otherwise, values will be converted to floats
    /// directly without normalization.
    ///
    /// `vertex_attrib_pointer` specifies state for a generic vertex attribute array associated with a
    /// shader attribute variable declared with 64-bit double precision components. `gl_type`​ must be
    /// `Double`.
    ///
    /// If offset is not 0 a non-zero named buffer object must be bound to the `BufferTarget::Array`
    /// target (see `bind_buffer`), otherwise an error is generated. `offset` is treated as a byte
    /// offset into the buffer object's data store. The buffer object binding
    /// (`GL_ARRAY_BUFFER_BINDING`) is saved as generic vertex attribute array state
    /// (`GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`) for `attrib`​.
    ///
    /// When a generic vertex attribute array is specified `size​`, `gl_type​`, `normalize`, `stride​`,
    /// and `offset` are saved as vertex array state, in addition to the current vertex array buffer
    /// object binding.
    ///
    /// To enable and disable a generic vertex attribute array, call `enable_vertex_attrib_array` and
    /// `disable_vertex_attrib_array`. If enabled the generic vertex attribute array is used when
    /// `draw_arrays`, `multi_draw_arrays`, `draw_elements`, `multi_draw_elements`, or
    /// `draw_range_elements` is called.
    ///
    /// # Parameters
    ///
    /// - `attrib` - Specifies the generic vertex attribute to be modified.
    /// - `size` - Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4.
    ///   Additionally, the symbolic constant `GL_BGRA` is accepted by `vertex_attrib_pointer`. The
    ///   initial value is 4.
    /// - `type` - Specifies the data type of each component in the array. The different functions
    ///   take different values. The initial value is `Float`.
    /// - `normalize` - Specifies whether fixed-point data values should
    ///   be normalized (`true`) or converted directly as fixed-point values (`false`) when they are
    ///   accessed.
    /// - `stride` - Specifies the byte offset between consecutive generic vertex attributes. If
    ///   stride​ is 0 the generic vertex attributes are understood to be tightly packed in the array.
    ///   The initial value is 0.
    /// - `offset` - Specifies the offset of the first component of the first generic vertex
    ///   attribute in the array in the data store of the buffer currently bound to the `ArrayBuffer`
    ///   target. The initial value is 0.
    ///
    /// # Notes
    ///
    /// - Each generic vertex attribute array is initially disabled and isn't accessed when
    ///   `draw_arrays`, `multi_draw_arrays`, `draw_elements`, `multi_draw_elements`, or
    ///   `draw_range_elements`​ is called.
    /// - `GL_UNSIGNED_INT_10F_11F_11F_REV` is accepted for `gl_type​` only if the GL version is 4.4 or
    ///   higher.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if index​ is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.
    /// - `GL_INVALID_VALUE` is generated if size​ is not 1, 2, 3, 4, or `GL_BGRA`.
    /// - `GL_INVALID_ENUM` is generated if type​ is not an accepted value.
    /// - `GL_INVALID_VALUE` is generated if stride​ is negative.
    /// - `GL_INVALID_OPERATION` is generated if size​ is `GL_BGRA` and type​ is not `UByte`,
    ///   `GL_INT_2_10_10_10_REV`, or `GL_UNSIGNED_INT_2_10_10_10_REV`.
    /// - `GL_INVALID_OPERATION` is generated if type​ is `GL_INT_2_10_10_10_REV` or
    ///   `GL_UNSIGNED_INT_2_10_10_10_REV` and size​ is not 4 or `GL_BGRA`.
    /// - `GL_INVALID_OPERATION` is generated if type​ is `GL_UNSIGNED_INT_10F_11F_11F_REV` and size​ is
    ///   not 3.
    /// - `GL_INVALID_OPERATION` is generated by if size​ is `GL_BGRA` and noramlized​ is `false`.
    /// - `GL_INVALID_OPERATION` is generated if zero is bound to the `BufferTarget::Array` buffer
    ///   object binding point and the offset argument is not 0.
    /// - `GL_INVALID_OPERATION` is generated if no vertex array object is bound.
    fn vertex_attrib_pointer(
        attrib: AttributeLocation,
        size: i32,
        gl_type: GlType,
        normalize: Boolean,
        stride: i32,
        offset: usize));

gl_proc!(glViewport:
    /// Sets the viewport.
    ///
    /// [Wiki Page](https://www.opengl.org/wiki/GLAPI/glViewport)
    ///
    /// Core since 1.0
    ///
    /// Specifies the affine transformation of `x` and `y` from normalized device coordinates to
    /// window coordinates. Let `(xnd, ynd)` be normalized device coordinates. Then the window
    /// coordinates `(xw, yw)` are computed as follows:
    ///
    /// ```
    /// xw = (xnd + 1)(width / 2) + x
    /// yw = (ynd + 1)(height / 2) + y
    /// ```
    ///
    /// Viewport width and height are silently clamped to a range that depends on the
    /// implementation. To query this range, call glGet with argument `GL_MAX_VIEWPORT_DIMS`.
    ///
    /// # Errors
    ///
    /// - `GL_INVALID_VALUE` is generated if either width or height is negative.
    fn viewport(x: i32, y: i32, width: i32, height: i32));

#[cfg(target_os = "windows")]
pub mod wgl {
    pub use platform::{
        create_context_attribs,
        get_extension_string,
        get_swap_interval,
        set_swap_interval,
    };
}
